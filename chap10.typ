#import "@preview/scripst:1.1.1": *

= 进程间通信

Inter Process Communication, IPC

== 进程间通信(IPC)概述

#note(subname: [问题])[
  *什么是通信？*
  - 在计算机系统中，“通信”指的是*两个或多个执行实体之间交换信息的行为*。
    - 在单机多进程系统中，这里的执行实体就是 进程。
    - 在分布式系统中，也可能是不同机器上的进程。
  - 一句话：IPC = 进程之间交换数据的方式。

  *为什么要进行通信？*
  - 进程之间必须共享数据或协调行为才能完成更复杂的任务。
  - 单个进程能做的事情有限，但多个进程协作能构建更强大的系统。例如：
    #three-line-table[
      | 场景         | 为什么需要通信？                 |
      | ---------- | ------------------------ |
      | shell 执行程序 | shell 命令解析后需要告诉子进程执行哪个程序 |
      | 浏览器和渲染进程   | 浏览器主进程将页面内容交给渲染进程        |
      | 客户端与服务器    | 典型的 socket 通信            |
      | 数据库系统      | 各种 worker、日志线程、检查点线程需要同步 |
    ]
    现代软件系统本质都是由多个协作的进程/线程组成，而协作离不开通信。

  *两个进程间有哪些通信需求？*
  - 基本通信需求
    - 数据传送
      - 一个进程需要把某些信息交给另一个（例如输入数据、计算中间结果）
    - 事件通知
      - “我做完了，你可以开始干你的事情了”
      - 或者：告诉另一个进程一个外部事件发生了（比如中断、SIGCHLD）
    - 同步（synchronization）
      - 保证两个进程按特定顺序执行
      - 避免竞争条件（race condition）
    - 资源共享
      - 多个进程共享内存、文件等，需要一定管理机制以避免冲突
    - 互斥（mutual exclusion）
      - 典型例子：共享缓冲区只能一个进程修改
  - 操作系统需要提供什么来满足这些需求？
    - 操作系统必须提供机制（mechanisms），使得进程可以安全、高效地通信。典型 IPC 机制包括：
    - 管道（pipe）
      - Unix 最经典的方式：`ls | grep txt`
      - 单向，半双工
      - 父子进程可用匿名管道；无亲缘关系进程要用命名管道
    - 消息队列（message queue）
      - 由 OS 管理的消息缓冲区
      - 进程以“消息”为单位收发信息
    - 共享内存（shared memory）
      - 多个进程映射到同一物理内存区域
      - 最快的 IPC 方式
      - 必须配套锁（信号量）
    - 信号（signal）
      - 发送异步通知，如 Ctrl + C 触发 SIGINT
    - 信号量（semaphore）与互斥锁（mutex）
      - 用来做进程间的同步与互斥
    - Socket
      - 最通用的方式
      - 本机跨进程通信 or 网络跨机器通信均可
]

=== 进程间通信概述

*进程间通信的需求*
- 挑战：单个程序的功能有限
- IPC的目标：多进程协作完成复杂应用需求
  - 功能模块化
  - 程序之间相对隔离
  - 多个程序合作可完成复杂任务
- *进程间通信的定义*：进程间通过数据交换（共享或传递）进行*交互*的行为
  #figure(
    image("pic/2025-11-20-20-03-47.png", width: 80%),
    numbering: none,
  )

*进程间的交互关系*
- 独立进程：与其它进程无交互
- 协作进程：两个或多个进程之间有交互
  - 发送者 接收者 / 客户端 服务端
  - `cat README.md | grep rcore`
    - `grep`依赖`cat`：`grep`等`cat`产生的输出作为其输入，来匹配字符串

*进程通信方式*
- *直接通信*：两个进程间不需要通过内核的中转，就可以相互传递信息
  - ```两进程映射同一块物理内存（共享内存段）
    进程 A 写 → 进程 B 立即可读```
  - 典型代表：
    - System V / POSIX 共享内存
    0 mmap 匿名映射
  - 特点：
    - 快（无需复制）
    - 危险（需要同步机制，否则会乱）
- *间接通信*：两个进程间通过系统调用和内核的中转，来相互传递消息
  - `进程 A 写数据 → 系统调用 → 内核缓冲区 → 系统调用 → 进程 B 读数据`
  - 典型代表：
    - pipe（管道）
    - FIFO
    - socket
    - 信号 signal
    - 消息队列 message queue
  - 特点：
    - 安全（数据隔离）
    - 慢（数据复制两次：A→kernel，kernel→B）
*IPC机制*
- 进程间能共享或传递数据就算是进程间通信。
  #three-line-table[
    | IPC机制|含义|通信方式|
    | --- | --- | --- |
    | 信号 (Signal)	|异步发送信号给进程处理|间接通信|
    | 管道 (Pipe)|单方向传输字节流|间接通信|
    | 消息队列 (Message Queue)|通过队列中转收/发消息|间接通信|
    | 套接字 (Socket)|多/单机进程间网络通信|间接通信|
    | 共享内存 (Shared Memory)|多个进程共享一块物理内存|直接通信|
    | 文件 (File)|多个进程可访问同一文件|间接通信|
  ]
- UNIX的典型IPC机制
  - Communication（数据通信）
    - Byte stream（字节流）：数据像水流一样顺序到达，对边界没有严格定义
      - pipe：父子进程常用
      - FIFO：命名管道，无父子关系也可通信
      - stream socket：网络通信的基础（TCP）
    - Message（消息）：消息以独立的 message 单位 传递，可以保留消息边界
      - System V 消息队列
      - POSIX 消息队列
      - datagram socket (UDP)
    - Shared Memory（共享内存）：共享内存是最快 IPC，但必须配合同步机制（例如信号量）
      - System V shared memory
      - POSIX shared memory
      - mmap（匿名映射、文件映射）
  - Signal（信号）
    - 标准信号（如 SIGINT, SIGKILL）
    - 实时信号（可排队，有优先级）
    - 用于：
      - 异步事件通知
      - 程序终止
      - 子进程状态变化（SIGCHLD）
  - Synchronization（同步）：用于协调多个进程对共享资源的访问：
    - 信号量（semaphore）
    - 文件锁（fnctl / flock）
    - 互斥锁（mutex，对于线程）
    - 条件变量（condition variable）
*消息传递的基本接口*
- 送(send)消息
- 收(recv)消息
- 程过程调用(RPC)
- 复(reply)消息
- Remote Procedure Call, RPC = send + recv
*阻塞或非阻塞通信*
- 阻塞通信:
  - 阻塞发送、阻塞接收
  - 进程调用如 read() 后：
    - 若数据未准备好 → 进程进入 sleep 状态
    - 数据 ready 后 → read 返回
  - 优点：逻辑简单
  - 缺点：进程可能被阻塞很久
- 非阻塞通信
  - 非阻塞发送、非阻塞接收
  - 调用 read()：
    - 若数据未准备好 → READ 立即返回（通常返回 EAGAIN）
    - 进程可以去做别的事情
    - 数据准备好后通过某种机制通知进程（如 epoll）
  - 优点：高并发 IO 的基础（现代网络服务器）
  - 缺点：代码复杂，需要事件循环
  #figure(
    image("pic/2025-11-20-20-20-44.png", width: 80%),
    numbering: none,
  )
*IPC的缓冲方式*
- 无限容量：发送方不需要等待
  - 无限缓冲区（理论模型）
  - 假设 Buffer 可以容纳任意数量的数据
  - 发送方永远不会阻塞
- 有限容量：通信链路缓冲队列满时，发送方必须等待
  - Buffer 有限
  - 当满了后，发送方：
    - 阻塞（阻塞模式）
    - 或 返回 EAGAIN（非阻塞模式）
    - PIPE、SOCKET、消息队列都属于这一类
- 0容量: 发送方必须等待接收方
  - 没有中间缓冲
  - 发送方必须等接收方 ready 才能传输
  - 典型例子：
    - rendezvous 模型（同步消息传递）
    - 部分 RPC 实现模式
  #figure(
    image("pic/2025-11-20-20-21-09.png", width: 80%),
    numbering: none,
  )

=== 管道(pipe)

*管道(pipe)*
- 管道是一种进程间通信机制，也称为匿名管道(anonymous pipe)
  - 有读写端的一定大小的*字节队列*
  - *读端*只能用来从管道中读取
  - *写端*只能用来将数据写入管道
  - 读/写端通过*不同文件描述符*表示
  #three-line-table[
    | 特性         | 说明                      |
    | ---------- | ----------------------- |
    | 单向         | 不能同时双向通信（如需双向 → 建立两条管道） |
    | 有限容量       | 管道缓冲区大小一般 64KB（Linux）   |
    | 字节流        | 读写按照字节序列进行，没有消息边界       |
    | 只能在相关进程间使用 | 父子进程、兄弟进程               |
  ]
*创建管道*
```
int pipe(int pipefd[2])
```
返回：
- pipefd[0]：读端
- pipefd[1]：写端
管道本质是一个在内核中申请的 pipe 对象，每个进程拿到两个文件描述符
- 管道可表示为两个文件描述符加一段内核空间中的内存
- 创建管道时，返回两个文件描述符
  - 读管道
  - 写管道
  #figure(
    image("pic/2025-11-20-20-29-16.png", width: 80%),
    numbering: none,
  )
- 它的本质是：
  - 内核中开辟一块缓冲区（字节队列）
  - 两端通过 两个文件描述符 表示：
    - `pipefd[0]` → 读端（read）
    - `pipefd[1]` → 写端（write）
  - 两端是进程，管道在中间：
    ```
    Process A --fd[1]-->  [ pipe buffer ]  -->fd[0]-- Process B
    ```
*管道(pipe)的应用场景*
- 支持有关系的进程间通信
  - 父子进程、兄弟进程等
- 父进程创建管道(两个文件描述符)
  - 子进程会继承文件描述符，执行读写管道
- 通常管道两端的进程会各自关闭管道的一个文件描述符，如
  - 父进程关闭写描述符，只能向管道读数据
  - 子进程关闭读描述符，只能从管道写数据
  #figure(
    image("pic/2025-11-20-20-34-02.png", width: 80%),
    numbering: none,
  )
*管道实现机制*
#figure(
  image("pic/2025-11-20-20-36-10.png", width: 80%),
  numbering: none,
)
- pipe() 在内核中创建一个 pipe 对象
  - 其中包含：
    - 一个循环缓冲区（字节队列）
    - 读端引用计数
    - 写端引用计数
  - 文件描述符表：
    #three-line-table[
      | fd | 指向               |
      | -- | ---------------- |
      | 3  | pipefd[0] → 管道读端 |
      | 4  | pipefd[1] → 管道写端 |
    ]
  - write(pipefd[1], …)
    - 写端（W）将数据写入 pipe 缓冲区
    - 若缓冲区满 → 写阻塞
    - 若无读端 → 返回 SIGPIPE
  - read(pipefd[0], …)
    - 读端（R）从 pipe 缓冲区读出数据
    - 若缓冲区空 → 读阻塞
    - 若写端全部关闭 → read 返回 0（EOF）
*管道的典型用法：Shell 中的 "|"*
- 只需使用一根竖线 "|" 连接两个命令，Shell 做了以下几件事：
  - 调用 `pipe()` 得到读端和写端
  - `fork` 子进程运行 `cat`
    - 子进程 → `stdout` 被重定向到写端
  - `fork` 子进程运行 `grep`
    - 子进程 → `stdin` 被重定向到读端
  - Shell 关闭不需要的端
  - 最终形成数据流：
    ```
    cat stdout → pipe → grep stdin
    ```
*命名管道（named pipe）*
- 在shell中可用`mkfifo`命令创建命名管道，也称为FIFO。
- 匿名管道与命名管道都属于单向通信机制。两者的不同是：
  - 命名管道可以支持任意两个进程间的通信
  - 匿名管道只支持父子进程和兄弟进程间的通信
- 命名管道是阻塞式的单向通信管道
  - 任意一方都可以读、写
  - 只有读、写端同时打开了命名管道时，数据才会写入并被读取
  #three-line-table[
    | 对比项   | 匿名管道    | 命名管道（FIFO）    |
    | ----- | ------- | ------------- |
    | 建立方式  | pipe()  | mkfifo 产生一个文件 |
    | 文件系统  | 不存在     | 是文件（类型为 p）    |
    | 通信进程  | 必须有亲缘关系 | 任意两个进程        |
    | 阻塞    | 是       | 是             |
    | 单向/双向 | 单向      | 单向（如需双向需建两条）  |
  ]
  - 示例
    - Terminal A:
      ```bash
      mkfifo name.fifo
      echo README > name.fifo   # 阻塞等待……
      ```
    - Terminal B:
      ```bash
      cat name.fifo   # 解除 A 的阻塞
      ```
      当 B 打开读端时，A 才能把数据写进去。

=== 消息队列(Message Queue)
=== 共享内存(shared memory)
=== 信号(Signal)
