#import "@preview/scripst:1.1.1": *

= 基于特权级的隔离与批处理

== 从OS角度看计算机系统

=== OS与硬件的关系

*计算机系统*
- 计算机系统（computer architecture）是一种抽象层次的设计，用于实现可有效使用现有制造技术的信息处理应用。
*计算机系统抽象层次*
- 硬件 支持 OS 支持 应用
  - 操作系统位于硬件（HW）和应用（APP）之间
  - 只有理解OS与HW/APP的关系，才能更好掌握OS
*指令集：软硬件接口*
- 硬件与OS的边界：指令集+寄存器

=== OS与应用程序的关系

*OS对应用程序执行的支持*
- *提供服务*
  - 系统调用
  - 地址空间布局
    - mmu

#note(subname: [RISC-V的终端过程响应过程中执行了什么操作])[

]

OS为应用程序提供服务
- 通过系统调用来提供服务
- 系统调用：OS/APP的接口（边界之一）

系统调用如何实现？
- 调用`ssize_t read(int fd, void *buf, size_t count);`会发生什么？
- 可以在应用程序中直接调用内核的函数吗？
- 可以在内核中使用应用程序普通的函数调用吗？
  - 隔离

引入系统调用的目的是增强安全性和可靠性
- 函数调用的特征
  - 好处：执行很快；
  - 好处：灵活-易于传递和返回复杂数据类型；
  - 好处：程序员熟悉的机制,...
  - 坏处：应用程序不可靠，可能有恶意，有崩溃的风险

进程的地址空间
- 进程的地址空间（memory layout）是界定了OS/APP的边界。
- OS内核与应用进程的地址空间划分
  #figure(
    image("pic/2025-09-25-10-32-53.png", width: 80%),
    numbering: none,
  )
  - 6是`ecall`，从用户态进入内核态
  - 系统调用用软中断实现

=== 隔离机制

*隔离要解决的问题*
- 防止程序 X 破坏或监视程序 Y
  - 读/写内存，使用 100％的 CPU，更改文件描述符
- 防止进程干扰操作系统
- 防止恶意程序、病毒、木马和 bug
  - 错误的过程可能会试图欺骗硬件或内核
*隔离*
- 隔离（Isolation） 的定义
  - 指操作系统通过软硬件机制确保不同的进程、用户或虚拟机相互独立运行，避免彼此之间在执行、数据或资源使用上的干扰或未经授权的访问。
- 隔离的本质
  - 不同实体间具备交换或共享信息、资源的情况下，如何确保彼此之间的安全和独立运行
- 隔离并不意味着不要共享
*隔离边界*隔离需要建立边界（boundary）
- 边界决定了各自的势力范围
  - 跨界即有风险的共享资源
- 强制隔离
  - 避免有问题的单元对整个系统的安全影响
- 隔离的单位
  - 通常是运行的程序
*隔离方法*隔离的方法分类
- 基于软件的隔离
- 基于硬件的隔离
- 基于网络的隔离
#three-line-table[
  | 属性	| 描述 |
  | ---- | ---- |
  | 地址空间隔离（Address Space Isolation） | 页表。进程只能访问自己的内存空间，不能直接访问其他进程的地址空间。如使用虚拟内存实现隔离。 |
  | 文件系统隔离（File System Isolation） | 进程或容器只能访问自己的文件系统，不能访问其他进程的文件。例如，Linux 的 chroot 机制或容器的 OverlayFS。 |
  | 用户身份隔离(User Isolation) | 通过用户权限控制（如 UNIX 的 UID/GID）确保不同用户之间的资源访问受到限制。 |
  | 进程隔离（Process Isolation） | 进程之间通过进程表和内存管理保持独立，防止数据泄露和未授权访问。 |
  | 网络隔离（Network Isolation） | 通过防火墙、虚拟局域网（VLAN）或网络命名空间（Linux Namespace）限制不同进程、容器或 VM 之间的网络访问。 |
  | 计算资源隔离（Compute Resource Isolation） | 通过 CPU 亲和性（CPU Affinity）、cgroups（Control Groups）等技术限制进程或容器的 CPU、内存、磁盘 I/O 使用。 |
  | 时间隔离（Temporal Isolation） | 时钟中断。在实时系统或云计算环境中，确保任务获得预期的 CPU 时间片，避免一个任务长期占用 CPU 而影响其他任务。 |
]
- 对数据的隔离：*地址空间*
  - 用户地址空间 vs 内核地址空间
- 对控制的隔离：*特权级机制*
  - 用户态 vs 内核态
- 对时间的隔离：*时钟中断处理*
  - 随时打断正在执行的用户态App
- 对破坏隔离的处理：*异常处理*
  - OS在内核态及时处理用户态App的异常行为

- 数据隔离：*地址空间*
  - 地址空间 address spaces
    - 一个程序仅寻址其自己的内存
    - 若无许可，则每个程序无法访问不属于自己的内存
  - 虚拟内存需要解决的问题
    - 读写内存的安全性问题
    - 进程间的安全问题
    - 内存空间利用率的问题
    - 内存读写的效率问题
  #figure(
    image("pic/2025-09-25-10-48-24.png", width: 80%),
    numbering: none,
  )
- 控制隔离：*特权模式*
  - 特权模式是 CPU 提供的一种机制，它将 CPU 的执行权限划分为不同的级别，防止低权限代码访问或修改高权限的系统资源。
  - CPU 硬件中的特权模式
    - *保护操作系统内核*，防止应用直接访问关键数据或执行特权指令
    - *防止应用恶意或错误访问硬件状态*：控制寄存器、内存管理单元
    - *提供受控的系统调用接口*：应用可受限制地请求操作系统服务
  - CPU 硬件支持不同的特权模式
    - Kernel Mode（内核态） vs User Mode（用户态）
    - 内核态可以执行用户态无法执行的特权操作
      - 访问外设
      - 配置地址空间（虚拟内存）
      - 读/写特殊系统级寄存器
    - OS内核运行在内核态
    - 应用程序运行在用户态
    - 每个微处理器都有类似的用户/内核模式标志
- 时间隔离：时钟中断 --v.s.-- 控制隔离：异常和陷入
  - CPU 硬件支持中断/异常的处理
    - 异常(Exception）： CPU 执行指令时*检测到错误*（如除零错误、缺页异常），立即触发异常处理例程
      - 异常是同步发生，是由由程序指令直接触发的错误或异常情况
    - 中断(Interrupt）： 是一种用于处理*外部或内部事件*的机制。当中断发生时，CPU 暂停当前执行的指令流，转而执行相应的中断处理例程
      - 时钟中断：定时器超时产生的中断，可控制CPU时间片
      - 中断是异步发生，由外部设备或异步事件触发，而非程序主动调用，这使得它们与当前指令流无直接关系
    - 陷入(Trap）： 也称*系统调用(Syscall)*，进程*主动*请求操作系统服务，需要从用户模式切换到内核模式
      - 陷入是同步触发的，因为它是程序主动发起的


陷入/系统调用处理例程
- 查找系统调用程序
- 用户态切换到内核态
- 栈切换，上下文保存
  - 分为用户栈和内核栈
  - 内核栈负责系统调用，大多数时间是空的
- 执行内核态
- 返回用户态

#note(subname: [小结])[
  - 计算机硬件与操作系统的关系：接口/边界
    - 指令集
  - 操作系统与应用程序的关系：接口/边界
    - 系统调用
  - 操作系统如何隔离与限制应用程序
    - 时间、空间、权限
]

== 从OS角度看RISC-V
