#import "@preview/scripst:1.1.1": *

= 基于特权级的隔离与批处理

== 从OS角度看计算机系统

#note(subname: [问题])[
  - 什么是计算机系统的层次结构？
    - 硬件层
      - 最底层：CPU、内存、I/O 设备
      - 提供最基础的算力和存储能力
    - 操作系统 (OS) 层
      - 在硬件之上运行，管理 CPU、内存和设备
      - 提供抽象（文件、进程、线程、虚拟内存、网络接口等）
    - 系统库 / 运行时层
      - 标准库（libc、Rust std 等），把 OS 接口打包成更好用的 API
      - 运行时（如 JVM、.NET CLR）也属于这一层
    - 应用程序层
      - 用户真正编写和运行的程序
      - 通过系统调用 / 库函数与操作系统交互
  - 层次结构中相邻层次间有什么区别？
    - 功能：下层提供抽象和服务，上层利用这些服务实现更复杂的功能
    - 访问方式：上层不能直接操作下层，只能通过规定好的接口（API/ABI/SBI）
    - 特权性：越往下的层次，越接近硬件，权限越高
  - 层次结构中相邻层次间的边界是什么？
    - 硬件 vs. 软件
      - 边界是*指令集架构 (ISA)*
      - ISA 定义了软件能用哪些指令、寄存器、内存访问方式
      - 不同 CPU 架构（x86, ARM, RISC-V）就是不同的 ISA
    - 操作系统 vs. 应用程序
      - 边界是*系统调用接口 (System Call Interface, SCI)*
      - 应用程序通过 `syscall/ecall` 进入内核，请求服务（如读文件、开线程）
      - OS 内核则在特权态执行，直接管理硬件
]

=== OS与硬件的关系

*计算机系统*
- 计算机系统（computer architecture）是一种抽象层次的设计，用于实现可有效使用现有制造技术的信息处理应用。
*计算机系统抽象层次*
- 硬件 支持 OS 支持 应用
  - 操作系统位于硬件（HW）和应用（APP）之间
  - 只有理解OS与HW/APP的关系，才能更好掌握OS
*指令集：软硬件接口*
- 硬件与OS的边界：指令集+寄存器
- OS是对硬件的虚拟与抽象
*RISC-V处理器架构*

#note(subname: [RISC-V 处理器内部架构图])[

  + *接口层 (左边灰色方块)*
    - *Instruction Interface*
      - 指令接口，从内存中取指令（通过总线或缓存）。
      - CPU 每一条执行的机器码指令就是从这里取来的。
    - *Data Interface*
      - 数据接口，用来访问主存或外设数据。
      - 比如执行 `lw`（load word）时，会通过数据接口访问内存。
    - *Debug Unit*
      - 调试单元，支持调试器 (GDB/JTAG) 与 CPU 通信。
      - 可用于设置断点、单步运行、读取寄存器状态。
    - *Configurable / Optional Unit*
      - 可配置接口和可选单元，用来扩展自定义指令或加速器。
      - RISC-V 的开放性在这里体现：用户可加定制逻辑。
  + *核心状态部件 (中间蓝色方块)*
    - *CPU State*
      - 记录当前 CPU 的运行状态（程序计数器 PC、模式位等）。
    - *Register File*
      - 通用寄存器组（RISC-V 有 32 个 64 位寄存器，如 `x0-x31`）。
      - 指令的操作数和结果会保存在寄存器里，比内存快得多。
    - *Instruction Cache (I-Cache)*
      - 指令缓存，减少从主存取指的延迟。
  + *流水线 (Execution Pipeline)*

    RISC-V 是一个典型的 *流水线 CPU*，每条指令经过一系列阶段：

    1. *Fetch*
      - 取指，从指令缓存或内存中拿到机器码。
    2. *Pre-Decode*
      - 预解码，初步识别指令类型。
    3. *Decode/Optimize*
      - 解码，把机器码翻译成内部控制信号。
      - 同时进行一些调度、优化（比如乱序执行的准备）。
    4. *Execute*
      - 在 ALU（算术逻辑单元）里执行运算。
      - 比如 `add x1, x2, x3` 就在这里做整数加法。
    5. *Memory Access*
      - 对需要访存的指令，在这里访问数据缓存 (D-Cache) 或内存。
    6. *Write Back*
      - 把运算/访存结果写回寄存器文件。


  + *性能优化单元 (右上角黄色方块)*

    - *Branch Predictor*
      - 分支预测器，用来预测分支指令（如 `if/else`、循环跳转）的走向。
      - 避免流水线停顿，提高性能。
    - *Data Cache (D-Cache)*
      - 数据缓存，加速访存。
      - 比如执行 `lw/sw` 时，先查缓存，不命中再去内存。


  *整体工作流程*
  1. *取指*：Instruction Interface → I-Cache → Fetch。
  2. *解码/执行*：Decode → Execute → Memory Access。
  3. *访存/写回*：数据通过 D-Cache 访问，结果写回寄存器。
  4. *性能优化*：分支预测减少停顿，缓存减少访存延迟。

]

=== OS与应用程序的关系

*OS对应用程序执行的支持*
- *提供服务*
  - 系统调用(System Call)
    - 应用程序不能直接操作硬件（磁盘、网卡、内存）
    - 过系统调用（syscall/ecall）向 OS 请求服务
  - 地址空间布局
    - 每个应用都在自己的虚拟地址空间里运行
    - 通过 MMU (Memory Management Unit) + 页表，虚拟地址会被映射到物理内存
      - 应用之间互不干扰（隔离）
      - 程序可以认为自己有“独占”的线性内存空间

#note(subname: [RISC-V的中断过程响应过程中执行了什么操作])[
  当应用程序运行时，如果发生*中断/异常*（例如 I/O 完成、非法指令、系统调用），CPU 会立即*切换到 OS 内核*来处理。

  过程大致如下：

  + 陷入 (Trap Enter)
    - CPU 保存当前执行状态：
      - 当前 pc（保存在 `sepc` CSR）
      - 异常原因（写入 `scause` CSR）
      - 其它必要寄存器
    - 切换到更高特权级（User → Supervisor）
    - 跳转到 OS 设置的中断向量表入口 (`stvec`)
  + 处理中断/异常
    - OS 内核在中断处理函数里，根据 `scause` 分析原因
    - 如果是系统调用 (`ecall` from U-mode)：进入内核，执行对应的服务（如 `read`）
    - 如果是外设中断（如时钟中断）：触发调度器，可能切换进程
  + 恢复 (Trap Return)
    - OS 执行 `sret` 指令：
      - 恢复 `sepc` 里的 PC，返回到用户态
      - 恢复用户态寄存器/栈
    - 应用程序从“被打断的下一条指令”继续运行
  其中：
  - `ecall`：RISC-V 指令集 (ISA) 的特权指令，Environment Call（环境调用），触发一个 陷入 (trap)，从用户态进入更高特权级（通常是内核态 Supervisor mode）
  - `sret`：RISC-V 特权指令，Supervisor Return 指令，从内核态返回用户态
  - CSR（Control and Status Registers）：RISC-V 的控制状态寄存器，用于保存特权级状态、中断信息等
  - `sepc`：属于 CSR，Supervisor Exception Program Counter，当 trap（中断/异常/系统调用）发生时，CPU 自动把触发 trap 的指令地址 存到 `sepc`
  - `scause`：属于 CSR，Supervisor Cause Register，保存引发 trap 的原因（中断号或异常代码）
]

#newpara()

*OS为应用程序提供服务*
- 通过系统调用来提供服务
- 系统调用：OS/APP的接口（边界之一）

- *系统调用如何实现？*
  - 系统调用如何实现？系统调用（system call）是应用程序访问内核功能（文件、进程、网络等）的唯一正规途径。它的核心机制是 特权级切换：
    + 应用程序调用 C 库函数（如 `read`、`write`），这些函数不是直接操作硬件，而是封装了系统调用接口
    + C 库内部发出一条陷入指令（在 RISC-V 中是 `ecall`，在 x86 中是 `int 0x80` 或 `syscall`）
    + CPU 检测到 `ecall` → 触发 陷入 (trap)，硬件自动：
      - 保存当前 PC 到 `sepc`
      - 写入 `scause`，说明是系统调用
      - 跳转到内核事先设置好的入口（`stvec` 指向的 trap handler）
    + 内核 trap handler 解析系统调用号和参数（从寄存器里取出）
    + 内核执行对应的服务逻辑（比如读文件、调度进程）
    + 内核完成后，用 `sret` 返回 → 从 `sepc` 继续执行应用代码
    - 实现了*用户态 → 内核态 → 用户态*的受控切换
  - 调用`ssize_t read(int fd, void *buf, size_t count);`会发生什么？
    + 用户写下：`read(fd, buf, count);`
    + 编译后的程序实际上会调用 glibc 提供的封装函数 `read`
    + `glibc::read` 内部：
      - 把参数放入指定寄存器（RISC-V 里 `a0=fd`, `a1=buf`, `a2=count`）
      - 把系统调用号（`__NR_read`，比如 63）放到 `a7`
      - 执行 `ecall`
    + CPU 硬件陷入内核 → 内核 trap handler 看到 `a7=63`，知道这是 `sys_read`
    + 内核根据 `fd` 找到文件对象，从磁盘/缓存里读数据，写入 `buf` 指向的用户内存
    + 返回实际读取的字节数，放到 `a0`
    + CPU 执行 `sret` → 回到用户态，用户得到 `read()` 的返回值
  - 可以在应用程序中直接调用内核的函数吗？
    - 不可以，至少不能像调用普通函数那样直接调用。原因：
      - 地址空间隔离：用户程序根本看不到内核的物理地址，直接调用会导致非法访问（segfault）
      - 特权级限制：即使知道内核函数地址，用户态也没有权限执行那些特权指令或访问受保护资源
      - 必须通过*系统调用接口（ecall）*来间接使用内核的功能
  - 可以在内核中使用应用程序普通的函数调用吗？
    - 也不行，原因不同：
      - 应用程序代码不在内核可信的执行路径里，内核不能随便跳过去执行用户代码，否则安全性崩溃
      - 内核和应用处于不同的执行上下文，内核只会：
        - 读写应用内存（经过地址检查）
        - 调用自己的内核函数（比如 sys_read、schedule）
      - 内核不会像调用内部函数那样直接调用用户函数
    - 隔离
- *引入系统调用的目的是增强安全性和可靠性*
  - 函数调用的特征
    - 好处
      - 执行很快；
      - 灵活-易于传递和返回复杂数据类型；
      - 程序员熟悉的机制,...
    - 坏处：应用程序不可靠，可能有恶意，有崩溃的风险

*进程的地址空间*
- 进程的*地址空间*（memory layout）是界定了OS/APP的*边界*
  - 用户空间 (User Space)
    - 每个应用程序都有自己独立的用户空间地址，通常从 `0x00000000` 到某个高地址（例如 `0xBFFFFFFF`）
    - 应用程序的代码、数据、堆、栈都在这里
    - 应用只能在这里运行，不能直接操作硬件或访问内核空间
  - 内核空间 (Kernel Space)
    - 系统中所有进程共享的高地址部分（如 `0xC0000000` 以上， `0xFFFFFFFF` 往下）
    - 内核代码、设备驱动、内核数据结构、页表、I/O 缓冲区都在这里
    - 只有在内核态时才能访问
- OS内核与应用进程的地址空间划分
  #figure(
    image("pic/2025-09-25-10-32-53.png", width: 80%),
    numbering: none,
  )
  - 1-3用户程序准备参数：把 `nbytes`、`&buffer`、`fd` 压入栈。
  - 4调用库函数 `read`
  - 5`read`（glibc 封装）会把这些参数放到寄存器，并设置系统调用号
  - 6是陷入指令`ecall`，从用户态进入内核态
  - CPU 硬件自动保存用户态的执行上下文（如 PC → `sepc`，原因码 → `scause`）
  - 7分派器根据系统调用号找到对应的内核函数，比如 `sys_read`
  - 8内核执行具体的操作：检查 fd，从文件系统 / 设备驱动读取数据，写入用户缓冲区
  - 内核完成后，将返回值写到寄存器 `a0`
  - 9执行 `sret`，恢复到用户态
  - 10应用程序从 `read` 调用返回，继续执行
  - 系统调用用软中断实现

=== 隔离机制

*隔离要解决的问题*
- 防止程序 X 破坏或监视程序 Y
  - 读/写内存，使用 100％的 CPU，更改文件描述符
- 防止进程干扰操作系统
- 防止恶意程序、病毒、木马和 bug
  - 错误的过程可能会试图欺骗硬件或内核
*隔离*（Isolation）
- 指操作系统通过软硬件机制确保不同的进程、用户或虚拟机相互独立运行，避免彼此之间在执行、数据或资源使用上的干扰或未经授权的访问。
- 隔离的本质
  - 不同实体间具备交换或共享信息、资源的情况下，如何确保彼此之间的安全和独立运行
- 隔离并不意味着不要共享
*隔离边界*：隔离需要建立边界（boundary）
- 边界决定了各自的势力范围
  - 跨界即有风险的共享资源
- 强制隔离
  - 避免有问题的单元对整个系统的安全影响
- 隔离的单位
  - 通常是运行的程序
*隔离方法*：隔离的方法分类
- 基于软件的隔离
- 基于硬件的隔离
- 基于网络的隔离
#three-line-table[
  | 属性	| 描述 |
  | ---- | ---- |
  | 地址空间隔离（Address Space Isolation） | 页表。进程只能访问自己的内存空间，不能直接访问其他进程的地址空间。如使用虚拟内存实现隔离。 |
  | 文件系统隔离（File System Isolation） | 进程或容器只能访问自己的文件系统，不能访问其他进程的文件。例如，Linux 的 chroot 机制或容器的 OverlayFS。 |
  | 用户身份隔离(User Isolation) | 通过用户权限控制（如 UNIX 的 UID/GID）确保不同用户之间的资源访问受到限制。 |
  | 进程隔离（Process Isolation） | 进程之间通过进程表和内存管理保持独立，防止数据泄露和未授权访问。 |
  | 网络隔离（Network Isolation） | 通过防火墙、虚拟局域网（VLAN）或网络命名空间（Linux Namespace）限制不同进程、容器或 VM 之间的网络访问。 |
  | 计算资源隔离（Compute Resource Isolation） | 通过 CPU 亲和性（CPU Affinity）、cgroups（Control Groups）等技术限制进程或容器的 CPU、内存、磁盘 I/O 使用。 |
  | 时间隔离（Temporal Isolation） | 时钟中断。在实时系统或云计算环境中，确保任务获得预期的 CPU 时间片，避免一个任务长期占用 CPU 而影响其他任务。 |
]
- 对数据的隔离：*地址空间*
  - 用户地址空间 vs 内核地址空间
- 对控制的隔离：*特权级机制*
  - 用户态 vs 内核态
- 对时间的隔离：*时钟中断处理*
  - 随时打断正在执行的用户态App
- 对破坏隔离的处理：*异常处理*
  - OS在内核态及时处理用户态App的异常行为

- *数据隔离：地址空间*
  - 地址空间 address spaces
    - 一个程序仅寻址其自己的内存
    - 若无许可，则每个程序无法访问不属于自己的内存
  - 虚拟内存需要解决的问题
    - 读写内存的安全性问题
    - 进程间的安全问题
    - 内存空间利用率的问题
    - 内存读写的效率问题
  #figure(
    image("pic/2025-09-25-10-48-24.png", width: 80%),
    numbering: none,
  )
- *控制隔离：特权模式*
  - 特权模式是 CPU 提供的一种机制，它将 CPU 的执行权限划分为不同的级别，防止低权限代码访问或修改高权限的系统资源。
  - CPU 硬件中的特权模式
    - *保护操作系统内核*，防止应用直接访问关键数据或执行特权指令
    - *防止应用恶意或错误访问硬件状态*：控制寄存器、内存管理单元
    - *提供受控的系统调用接口*：应用可受限制地请求操作系统服务
  - CPU 硬件支持不同的*特权模式*
    - *Kernel Mode（内核态） vs User Mode（用户态）*
    - 内核态可以执行用户态无法执行的特权操作
      - 访问外设
      - 配置地址空间（虚拟内存）
      - 读/写特殊系统级寄存器
    - OS内核运行在*内核态*
    - 应用程序运行在*用户态*
    - 每个微处理器都有类似的用户/内核模式标志
- *时间隔离：时钟中断 --v.s.-- 控制隔离：异常和陷入*
  - CPU 硬件支持中断/异常的处理
    - 异常(Exception）： CPU 执行指令时*检测到错误*（如除零错误、缺页异常），立即触发异常处理例程
      - 异常是同步发生，是由由程序指令直接触发的错误或异常情况
    - 中断(Interrupt）： 是一种用于处理*外部或内部事件*的机制。当中断发生时，CPU 暂停当前执行的指令流，转而执行相应的中断处理例程
      - 时钟中断：定时器超时产生的中断，可控制CPU时间片
        - Timer 可以稳定定时地产生中断
          - 防止应用程序死占着 CPU 不放
          - 让OS内核能周期性地进行资源管理
      - 中断是异步发生，由外部设备或异步事件触发，而非程序主动调用，这使得它们与当前指令流无直接关系
    - 陷入(Trap）： 也称*系统调用(Syscall)*，进程*主动*请求操作系统服务，需要从用户模式切换到内核模式
      - 陷入是同步触发的，因为它是程序主动发起的
  - *中断处理例程*（interrupt handle）：硬件中断/异常的处理程序
    + I/O 设备通过向处理器芯片的一个引脚发信号，并将异常号放到系统总线上，以触发中断；
    + 在当前指令执行完后，处理器从系统总线读取异常号，保存现场，切换到*内核态*；
    + 调用中断处理例程，当中断处理程序完成后，它将控制返回给下一条本来要执行的指令。
    - 触发中断
    - 保存现场，切换到内核态运行
    - 返回，恢复中断前下一条指令
  - *异常处理例程*
    - 根据异常编号去查询处理程序
    - 保存现场
    - 异常处理：杀死产生异常的程序；或者 重新执行异常指令
    - 恢复现场
  - *陷入/系统调用处理例程*
    - 查找系统调用程序
    - 用户态切换到内核态
    - 栈切换，上下文保存
      - 分为用户栈和内核栈
      - 内核栈负责系统调用，大多数时间是空的
    - 执行内核态
    - 返回用户态
  #three-line-table[
    | \ | 中断 | 异常 | 陷入/系统调用 |
    | ---- | ---- | ---- | ---- |
    | 发起者 | 外设、定时器 | 应用程序 | 应用程序 |
    | 触发机制 | 被动触发 | 内部异常、故障 | 自愿请求 |
    | 处理机制 | 持续，用户透明 | 杀死或重新执行 | 等待和持续 |
  ]

#note(subname: [小结])[
  - 计算机硬件与操作系统的关系：接口/边界
    - 指令集
  - 操作系统与应用程序的关系：接口/边界
    - 系统调用
  - 操作系统如何隔离与限制应用程序
    - 时间、空间、权限
]

== 从OS角度看RISC-V
