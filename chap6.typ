#import "@preview/scripst:1.1.1": *

= 虚拟存储管理

== 虚拟存储概念

#note(subname: [问题])[
  如何运行代码占用空间大于物理内存的程序？
  - 问题：
    - 程序太大，装不下
    - 程序各部分使用频率不同，有的常用，有的几乎不用
    - 如果能“只把需要的部分放进内存”，就能节省空间
  - 我们希望：
    - 程序在运行时不需要完全加载进物理内存
    - 只在需要访问某一部分时，才加载对应页
    - 当物理内存不够时，把暂时不用的页换出去
  - 这就是*虚拟存储（Virtual Memory）*的思想
  虚拟存储的核心理念
  - 用磁盘（外存）扩展内存容量，让程序“以为”它在访问一个巨大的内存空间
  - 操作系统通过*虚拟内存页表 + 缺页中断机制*实现这一点
    #three-line-table[
      | 层次            | 存储介质  | 速度 | 容量    | 是否可寻址   |
      | ------------- | ----- | -- | ----- | ------- |
      | L1/L2 Cache   | CPU内部 | 极快 | KB级   | 否（硬件透明） |
      | 内存 (RAM)      | DRAM  | 快  | MB~GB | 可寻址   |
      | 磁盘 (Disk/SSD) | 外存    | 慢  | GB~TB | 可寻址   |
    ]
  - 虚拟内存（VM）就是把 RAM + 磁盘的一部分（Swap 或 Page File）统一抽象成一个“巨大的逻辑内存”
  虚拟存储系统的关键机制
  - 实现“虚拟存储”需要操作系统 + 硬件的共同支持：
    #three-line-table[
      | 机制                           | 说明                   |
      | ---------------------------- | -------------------- |
      | *页表 (Page Table)*          | 建立虚拟页与物理页、外存页之间的映射关系 |
      | *缺页中断 (Page Fault)*        | 当访问的虚拟页不在内存中时触发中断    |
      | *页面置换 (Page Replacement)*  | 从内存中换出旧页，把新页调入       |
      | *磁盘交换区 (Swap / Page File)* | 存放被换出的页内容            |
    ]
  整体工作流程：
  - 程序访问一个虚拟地址（VA）
  - 硬件（MMU）查页表：
    - 若页表中标记为“存在 (Present=1)”，直接访问物理页
    - 若标记为“不在内存 (Present=0)”，触发缺页异常
  - 缺页异常处理程序：
    - OS 查找该页在磁盘中的位置
    - 分配一个空闲物理页
    - 把该页内容从磁盘读入
    - 更新页表项（设为 Present=1）
    - 重新执行指令
  - 若内存已满，先执行页面置换算法（LRU / FIFO / Clock）
  虚拟存储的三层映射关系
  - 在虚拟存储系统中，一个虚拟页（VPN）可能有三种状态：
    #three-line-table[
      | 状态                          | 存放位置     | 页表中的标志           | 行为           |
      | --------------------------- | -------- | ---------------- | ------------ |
      | *驻留页 (Resident Page)*     | 已加载到内存   | Present=1        | 可直接访问        |
      | *换出页 (Swapped-out Page)*  | 存放在磁盘交换区 | Present=0, 有磁盘地址 | 触发缺页时换入      |
      | *未分配页 (Unallocated Page)* | 尚未分配     | 页表项无效            | 访问时报错（例如段错误） |
    ]
  虚拟存储与分页机制的关系
  - 分页机制解决的是：“虚拟地址 → 物理地址”的静态映射问题
  - 虚拟存储进一步扩展成：“虚拟地址 → （物理地址 或 磁盘地址）”的动态映射问题
  常见虚拟存储实现方式
  - #three-line-table[
      | 系统                | 虚拟存储机制            | 特点          |
      | ----------------- | ----------------- | ----------- |
      | *Linux / Unix*  | Swap + Page Cache | 页粒度换入换出     |
      | *Windows*       | Pagefile.sys      | 系统自动管理大小    |
      | *macOS*         | Unified VM System | 动态压缩 + 交换文件 |
      | *rCore / uCore* | 教学实验性 VM          | 仅实现页级换入换出逻辑 |
    ]
  如何运行代码占用空间大于物理内存的程序？
  - 使用 按需分页 (Demand Paging)，只加载当前需要的页
  如何判断需要执行的代码是否在内存中？
  - 页表项中的存在位（Present bit）告诉 CPU 该页是否驻留内存
  当代码不在内存时，如何把它搬回来？
  - 通过 缺页中断 + 页面置换 + 交换区，由内核完成自动调入
]

=== 虚拟存储技术的需求

*虚拟存储技术的需求背景*
- 程序规模的增长速度远大于存储器容量的增长速度
- 挑战：计算机系统时常出现内存不够用
- 思路：内存不够，外存来补
  - 函数覆盖（overlay）
    - 应用程序以函数/模块为单位手动换入换出内存
  - 程序交换（swapping）
    - 操作系统以程序为单位自动换入换出内存
  - 虚拟存储(virtual storage)
    - 操作系统以页为单位自动换入换出内存
    - 虚拟存储=内存+外存

*地址空间：操作系统的抽象层*
- 地址空间（Address Space）是 OS 对虚拟存储的统一抽象
- 每个进程都有独立的地址空间
- 每个地址空间都由页表描述
- OS 负责在物理内存与磁盘间动态调度页
- 对进程来说，它“看到”的地址空间是连续且完整的
- 实际上，它只在内存中驻留了少量“活跃页”
  #figure(
    image("pic/2025-10-23-19-27-07.png", width: 80%),
    numbering: none,
  )
  - 上层（P1、P2、P3、内核）
    - 每个进程看到的虚拟地址空间都是完整的、独立的、0～2³²−1：
      - 虚拟地址空间相互独立
      - 各自都有代码段、数据段、栈段
      - 但这些虚拟地址实际映射到不同的物理页
    - 这就是“地址空间隔离”的实现
  - 中层（RAM，物理内存）
    - 这是真正的 DRAM，容量为 m（远小于总需求 M）
      - MMU（内存管理单元）通过页表，决定哪些虚拟页当前在内存
      - 如果访问的页不在内存，MMU 会触发“缺页中断”
      - 内核会从外存把该页调入内存
  - 下层（磁盘/SSD，外存）
    - 容量为 M ≫ m
    - 存放被换出的页（也叫交换区 Swap Space）
    - 每个页在磁盘中都有一个对应的“备份位置”

=== 覆盖技术

*覆盖技术*
- 目标
  - 程序员*手动控制*在*较小的可用内存*中运行*较大的程序*
- 基本思路
  - *不同时间段*内执行的*函数或模块*共享一块有限的空间
  - 把程序划分成若干模块，只把当前需要执行的模块装入内存，不同时间执行的模块可以共用同一块内存区域

*覆盖的基本原理*
- 覆盖是指把一个程序*划分*为一系列功能相对独立的程序段，让执行时*不要求同时装入内存*的程序段组成一组（称为覆盖段），*共享*主存的同一个区域
  - 必要部分（常用）的代码和数据常驻内存
  - 可选部分（不常用）放在其他程序模块中，只在需要时装入内存
  - 不存在调用关系的模块可相互覆盖，共用同一块内存区域
- 程序分段
  - 程序被划分为若干独立功能模块（称为“覆盖段”）。
- 常驻区 + 覆盖区
  - 常驻区：始终在内存中（如主控模块、调度模块）
  - 覆盖区：按需装入的模块区
- 覆盖关系
  - 不会同时执行的模块共享同一个内存区域

*覆盖技术示例*
- 程序调用结构
  ```
  A(20K)
  ├── B(50K)
  │   └── D(30K)
  └── C(30K)
      ├── E(20K)
      └── F(40K)
  ```
  - 整个程序大小总计：190K
  - 但计算机内存只有 110K
- 覆盖分区设计方案
  #three-line-table[
    | 区域    | 内容       | 占用  | 特点     |
    | ----- | -------- | --- | ------ |
    | 常驻区   | A 模块     | 20K | 始终在内存中 |
    | 覆盖区 0 | B、E、F 共用 | 50K | 不会同时执行 |
    | 覆盖区 1 | C、D 共用   | 30K | 不会同时执行 |
  ]
*覆盖的运行机制*
- 当程序执行需要进入某个未在内存的模块时：
  - 程序发出“装入模块 X”的请求
  - 操作系统从外存中读取模块 X 到指定覆盖区
  - 若该区已有模块，则将其内容覆盖掉
  - 程序跳转到模块 X 的入口继续执行
- 这就是 “时间换空间” 的手段

*覆盖技术的不足*
- 增加编程困难
  - 需程序员划分功能模块，并确定模块间的覆盖关系
  - 增加了编程的复杂度
    - Turbo Pascal的Overlay系统单元支持程序员控制的覆盖技术
- 增加执行时间
  - 从外存装入覆盖模块
  - 时间换空间

=== 交换技术

*交换技术*
- 基本思路
  - 操作系统以*程序*为单位*自动*换入换出内存
- 方法
  - *换出(swap out)*：把一个执行程序的整个地址空间内容保存到外存
  - *换入(swap in)*：将外存中某执行程序的地址空间内容读入到内存

*交换技术面临的问题*
- 交换*时机*：何时需要发生交换？
  - 只当内存空间不够或有不够的可能时换出
- 程序换入时的*重定位*：换出后再换入时要放在原处吗？
  - 不一定在原处，需要某种机制保证程序正确寻址&执行
- 交换区（空间）大小
  - 经验值。下面是Linux专家给出的建议
    #three-line-table[
      | 物理内存       | 建议的交换空间 | 启用休眠时建议   |
      | ---------- | ------- | --------- |
      | ≤ 2GB      | 内存的 2 倍 | 内存的 3 倍   |
      | 2GB – 8GB  | 等于内存大小  | 内存的 2 倍   |
      | 8GB – 64GB | 至少 4GB  | 内存的 1.5 倍 |
      | > 64GB     | 至少 4GB  | 不建议休眠     |
    ]

*覆盖与交换的比较*
- #three-line-table[
    | 对比维度     | 覆盖技术 (Overlay) | 交换技术 (Swapping) |
    | -------- | -------------- | --------------- |
    | 换入换出单位   | 模块 / 函数        | 整个程序（进程）        |
    | 触发方式     | 程序员手动          | 操作系统自动          |
    | 是否需要程序划分 | ✅ 需要           | ❌ 不需要           |
    | 调度粒度     | 模块级            | 进程级             |
    | 是否支持并发程序 | ❌ 否            | ✅ 是             |
    | 时间成本     | 程序 I/O 较少      | 整个程序 I/O，开销更大   |
    | 空间利用     | 较灵活            | 较粗糙             |
  ]

=== 虚拟存储的基本概念

*虚拟存储的定义*
- 定义
  - 虚拟存储 = *内存 + 外存*
- 思路
  - 操作系统将不常用的部分内存暂存到外存，将要处理器访问的数据从外存装入内存
- 前提
  - 程序具有*局部性*

#figure(
  image("pic/2025-10-23-20-38-01.png", width: 80%),
  numbering: none,
)
从左到右依次是：
#three-line-table[
  | 部分                  | 含义        | 说明                   |
  | ------------------- | --------- | -------------------- |
  | *Virtual Memory*  | 虚拟内存      | 每个进程看到的完整地址空间（如4GB）  |
  | *Memory Map*      | 页表映射表     | 保存虚拟页号 → 物理页号 或 磁盘位置 |
  | *Physical Memory* | 实际内存      | 只保存当前活跃的部分页          |
  | *Disk*            | 外存（Swap区） | 存放暂未用到的页             |
]
当访问到一个页：
- 若该页在内存，直接访问
- 若不在，触发缺页中断 → OS 从磁盘中加载 → 更新页表 → 重新执行指令

*局部性原理*
- 局部性（locality）：程序在执行过程中的一个*较短时期*，所执行的指令地址和指令的*操作数*地址，分别局限于*一定区域*
  - *时间*局部性：一条*指令*的一次执行和下次执行，一个*数据*的一次访问和下次访问都集中在一个*较短时期*内
  - *空间*局部性：当前指令和邻近时间的几条*指令*，当前访问的*数据*和邻近时间访问的几个数据都集中在一个*较小区域*内
  - *分支*局部性：一条*跳转指令*的两次执行，很可能*跳到相同的内存位置*
- 局部性的意义：如果大部分程序运行具有局部性特征，则虚拟存储技术是能够实现的，而且可取得满意的效果

*虚拟存储的思路与规则*
- 思路：将*不常用*的部分内存块暂存到外存
- 规则：
  - *装载*程序时：只将*当前指令执行需要的*部分页面或段装入内存
  - 指令执行中需要的指令或数据*不在内存*（称为缺页或缺段）时：处理器通知操作系统将相应的页面或段调入内存
  - 操作系统将内存中*暂时不用*的页面或段保存到外存
- 实现方式：
  - 虚拟页式存储
  - 虚拟段式存储
*虚拟存储的基本特征*
- 不连续性
  - 物理内存分配非连续
  - 虚拟地址空间使用非连续
- 大用户空间
  - 提供给用户的虚拟内存可大于实际的物理内存
- 部分交换
  - 虚拟存储只对部分虚拟地址空间进行调入和调出

*虚拟存储的底层支撑*
- 硬件(MMU/TLB/PageTable)
  - 页式或段式存储中的硬件地址转换机制、硬件异常
- 软件(OS)
  - 内存中建立页表或段表
  - 管理内存和外存间页面或段的换入和换出

*虚拟页式存储管理*
- 在页式存储管理的基础上，增加请求调页和页面置换
- 基本思路
  - 当用户程序要装载到内存时，只装入部分页面，就启动程序运行
  - 用户程序在运行中发现有需要的代码或数据不在内存时，则向系统发出缺页异常请求
  - 操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得用户程序能继续运行
  - 当内存快用完时，操作系统把部分页从内存调出到外存
- 关键机制：
  - 请求调页 (Demand Paging)
    - 程序访问某页时才装入内存
    - 减少启动时加载量，提高并发
  - 页面置换 (Page Replacement)
    - 当内存已满时，操作系统选择不常用页换出
    - 常见算法：FIFO、LRU、Clock 等
  - 缺页异常 (Page Fault)
    - 硬件检测到页不存在
    - 通知操作系统
    - 内核从磁盘加载页
    - 恢复执行

#figure(
  image("pic/2025-10-23-20-38-44.png", width: 80%),
  numbering: none,
)

缺页异常（Page Fault） 的完整处理路径：
- CPU 访问虚拟地址 (p, o)
- MMU 查页表：
  - 若页表中标志“有效位V=0”，说明该页不在内存
  - 触发*缺页异常 (Page Fault)*
- OS 缺页异常处理：
  - 暂停当前进程
  - 查找该页对应的磁盘位置
  - 从外存读入一页到物理内存
  - 修改页表：更新物理页号 + 设置有效位
  - 恢复程序运行（重新执行刚才那条指令）
- 关键点：程序并不知道发生了缺页中断，它会“自动恢复”

=== 缺页异常

*缺页异常的处理流程*
- CPU 尝试访问内存
  - CPU 发出虚拟地址
  - 先查 TLB（快表）
    - 命中 → 直接转换为物理地址
    - 未命中 → 查*页表*
- 页表项存在位 V=0
  - 页表中标志位“V=0”说明该页尚未装入内存
  - MMU 无法提供物理页号
  - CPU 触发一个“缺页异常”
  - 进入内核态，由操作系统处理
- OS 查找页的位置
  - 操作系统根据页表项或段描述符找到该页在外存中的位置
  - 位置信息可能在：
    - 页表项中（存有磁盘扇区号 / swap offset）
    - 或者在程序映射的文件描述符中（如 ELF 文件或共享库）
- 调入页（两种情况）
  #three-line-table[
    | 情况              | 说明                                                 |
    | --------------- | -------------------------------------------------- |
    | *有空闲物理页帧* | 直接从外存读取该页到空闲页帧中                                    |
    | *无空闲页帧*   | 启动*页面置换算法*（如 LRU、Clock），选出一个不常用页换出到外存，再读入所需页 |
  ]
- 更新页表
  - 页表项重新填写：
    - 有效位 V = 1
    - 填入新的物理页号
    - 若该页是可写页，还设置 D (Dirty)、A (Accessed) 等标志
  - 同时更新 TLB 或清空相关缓存项
- 恢复执行
  - OS 返回控制权给用户进程
  - CPU 重新执行刚才引发缺页的指令
  - 这次页表有效 → 正常访问

#figure(
  image("pic/2025-10-23-21-31-10.png", width: 80%),
  numbering: none,
)

*未被映射的页存放在哪里？*
- 交换空间（磁盘/文件形态）
  - 采用特殊格式存储未被映射的页面
  - 磁盘分区：一般是扇区地址
  - 在存在位为0的页表项中保存外存的页地址
- 磁盘上的文件(代码或数据)
  - 地址空间中的逻辑段表示中有对应的文件位置
    - 如：`MemorySet::MapArea`
  - 代码段：可执行二进制文件
  - 动态加载的共享库程序段：动态调用的库文件
  #three-line-table[
    | 存放位置                   | 说明                          |
    | ---------------------- | --------------------------- |
    | *交换空间（Swap Space）*   | 一块磁盘区域，用于存储被换出的匿名页（堆、栈等）    |
    | *文件映射（File Mapping）* | 程序代码、动态库、mmap文件页等，直接与磁盘文件对应 |
  ]
- 进一步细分
  - 匿名页 (Anonymous Page)
    - 没有文件后备，如堆、栈；换出时存到 swap
  - 文件页 (File-backed Page)
    - 来自可执行文件、动态库；可直接从文件重新加载

*页表中如何记录外存页位置*
- 当页不在内存中时：
  - 页表项的有效位 V=0
  - 其余字段（PPN）可以被操作系统暂时重载为：
    - 对应的 磁盘块号 / 扇区号
    - 或指向一个 文件映射表（MapArea）

*虚拟存储的性能*
- 有效存储访问时间（EAT, Effective memory Access Time）
  - EAT = 内存访问时间$times(1-p)$ + 缺页异常处理时间
  - 缺页异常处理时间 = 磁盘访问时间$times p(1+q)$
  - $p$: 缺页率；
  - $q$: 写回概率（淘汰一个页面到磁盘）

== 局部页面置换算法

#note(subname: [问题])[

  由于内存空间有限，而每个进程的虚拟地址空间可能远大于物理内存。当发生缺页异常（Page Fault）且没有空闲页帧时，操作系统必须选择一个现有页换出（Swap Out），把新的页换入（Swap In）。

  页面置换策略分类
  - #three-line-table[
      | 类型                           | 说明                      | 特点               |
      | ---------------------------- | ----------------------- | ---------------- |
      | *全局置换（Global Replacement）* | 各进程共享页帧池，缺页时可从任意进程中选页换出 | 内存利用率高，但进程性能不可预测 |
      | *局部置换（Local Replacement）*  | 每个进程有自己固定的页帧集合，只在其中选页换出 | 控制简单、稳定性好        |
    ]
  页面置换算法的设计思路
  - 置换条件（何时）
    - 发生缺页且内存已满时
    - 系统可能还会根据内存压力提前触发“预置换”
  - 选择条件（换谁）
    - 目标：换出“近期最不可能再被访问”的页
    - 依据：页面历史访问记录（或近似值）
  经典局部置换算法
  - 以下是按“精度 → 代价”递减排列的主流算法：
    #three-line-table[
      | 算法                | 思想           | 是否理想         | 实现复杂度       |
      | ----------------- | ------------ | ------------ | ----------- |
      | *OPT (Optimal)* | 换出未来最久不用的页   | ✅ 理论最优       | ❌ 未来不可知     |
      | *FIFO (先进先出)*   | 换出最早进入内存的页   | ❌ 容易Belady异常 | ✅ 简单        |
      | *LRU (最近最少使用)*  | 换出最近最久未使用的页  | ✅ 近似OPT      | ⚙️ 需硬件支持    |
      | *Clock (时钟)*    | LRU的高效近似算法   | ✅ 实用折中       | ✅ 常用        |
      | *LFU (最少使用次数)*  | 换出使用频率最低的页   | ⚙️ 慢响应短期变化   | ⚙️ 稀用       |
      | *NRU (未使用页面)*   | 根据最近访问位近似LRU | ✅ 快速实现       | ✅ Linux常用变种 |
    ]
  在进程执行的过程中，如何确实进程地址空间中哪些放到外存？
  - 由置换算法决定，优先换出近期/长期不再使用的页
  选择置换页面条件是什么？
  - 缺页异常且无空闲页帧
  在什么范围内进行页面置换？
  - 局部置换 → 当前进程页帧内；全局置换 → 所有进程页帧池
  置换条件的计算精度和开销如何取舍？
  - 精度高 → 代价大（LRU），折中算法（Clock）最常用
]

=== 页面置换算法的基本概念

*页面置换算法的功能与设计目标*
- 功能
  - 出现缺页异常需调入新页面而内存已满时，置换算法选择被置换的物理页面
- 设计目标
  - 尽可能减少页面*缺页次数、换入/换出次数*
  - 把未来*不再访问*或*短期内不访问*的页面调出
*页面置换的时机*
- *空闲内存*数量上限和下限
- 到达下限，开始回收内存
- 到达上限，暂停回收内存
  #figure(
    image("pic/2025-10-24-16-30-31.png", width: 80%),
    numbering: none,
  )
*页面置换处理流程*
- 缺页异常处理 + 页面置换过程
  #three-line-table[
    | 步骤           | 过程说明                                     |
    | :--- | --- |
    | *① load M* | CPU访问虚拟地址 M，页表项无效（V=0）                   |
    | *② 异常*     | MMU触发缺页异常，CPU陷入操作系统                      |
    | *③ 查找外存页面* | OS查页表/段表或文件映射信息，确定该页在外存位置                |
    | *④ 页面换入*   | 若有空闲页帧，直接从磁盘将页面读入；否则，执行置换算法选出牺牲页（可能需要写回） |
    | *⑤ 页表项修改*  | 更新页表项：设置新的物理页号、有效位V=1、清空脏位D=0 等          |
    | *⑥ 指令重执行*  | 返回用户态，重新执行触发缺页的那条指令                      |
  ]

*页面锁定(frame locking)/常驻内存*
- *必须常驻内存*的逻辑页面
  - 操作系统的关键部分（例如页表本身、调页中断处理代码）
  - 要求响应速度的代码和数据
  - 关键内核数据结构（例如 I/O 缓冲区）。
- 这类页面在页表项中会设置 锁定位（Lock Bit）：
  - 表示该页不可被置换（pinned / locked）

*页面置换算法的评价方法*
- 评价方法
  - 记录进程访问内存页面的轨迹，模拟置换行为，记录*缺页次数*
  - *更少的缺页，更好的性能*
- 示例: 虚拟地址访问用(页号, 位移)表示
  ```
  (3,0),  (1,9),  (4,1),  (2,1),  (5,3),  (2,0),  (1,9),  (2,4),  (3,1),  (4,8)
  ```
  对应的页面轨迹
  ```
  3, 1, 4, 2, 5, 2, 1, 2, 3, 4 用数字表示
  c, a, d, b, e, b, a, b, c, d 用字符表示
  ```
*页面置换算法的分类*
- *局部*页面置换算法
  - 置换页面的选择范围仅限于*当前进程*占用的物理页面内
  - 最优算法、先进先出算法、最近最久未使用算法
  - 时钟算法、最不常用算法
- *全局*页面置换算法
  - 置换页面的选择范围是*所有*可换出的物理页面
  - 工作集算法、缺页率算法
  #three-line-table[
    | 分类         | 范围               | 代表算法                       | 特点               |
    | ---------- | ---------------- | -------------------------- | ---------------- |
    | *局部页面置换* | 仅在当前进程的页帧中选择牺牲页  | OPT, FIFO, LRU, Clock, LFU | 稳定、独立性强          |
    | *全局页面置换* | 可在所有进程的页帧池中选择牺牲页 | 工作集算法、缺页率算法                | 提高整体利用率，但进程性能波动大 |
  ]

=== 最优页面置换算法 (OPT, optimal)

*最优页面置换算法的工作原理*
- 基本思路
  - 置换在*未来最长时间不访问*的页面
- 算法实现
  - 缺页时，计算内存中每个逻辑页面的*下一次访问时间*
  - 选择未来最长时间不访问的页面
*最优页面置换算法特征*
- 缺页最少，是*理想情况*
- 实际系统中*无法实现*
- *无法预知*每个页面在下次访问前的等待时间
  - 在模拟器上运行某个程序，并记录每一次的页面访问情况
  - 第二遍运行时使用最优算法
*最优页面置换算法示例*
#figure(
  image("pic/2025-10-24-16-43-39.png", width: 80%),
  numbering: none,
)
#three-line-table[
  | 特征        | 说明                           |
  | --------- | ---------------------------- |
  | *理论最优*  | 缺页率最低，是所有算法的性能上界             |
  | *不可实现*  | 需要预知“未来访问序列”，实际系统无法做到        |
  | *研究意义*  | 常作为其他算法（FIFO、LRU、Clock）的对比基准 |
  | *仿真可实现* | 在实验或模拟中可实现，通过“第二遍运行记录”访问序列   |
]

=== 先进先出页面置换算法 (FIFO)

*先进先出算法的工作原理*
- 基本思路
  - 选择在内存*驻留时间最长*的页面进行置换
- 算法实现
  - 维护一个记录所有*位于内存中的逻辑页面链表*
  - 链表元素*按驻留内存的时间排序*，链首最长，链尾最短
  - 出现缺页时，*选择*链首页面进行置换，新页面加到链尾
  - 由此形成一个“页面生命周期管理链”
*先进先出算法特征*
- 实现简单
- 性能较差，调出的页面可能是经常访问的
- 分配物理页面数增加时，缺页并不一定减少(Belady现象)
- 很少单独使用
*先进先出算法示例*
#figure(
  image("pic/2025-10-24-16-55-02.png", width: 80%),
  numbering: none,
)
#three-line-table[
  | 优点               | 缺点                             |
  | ---------------- | ------------------------------ |
  | ✅ 实现简单，易于硬件/软件支持 | ❌ 性能较差，可能换出“热门页”               |
  | ✅ 逻辑清晰（先进先出）     | ❌ 缺页率可能不随内存增加而下降（*Belady异常*） |
]
*Belady 异常（Belady’s Anomaly）*
- 增加物理页帧数后，缺页次数反而可能上升
- 例如：访问序列 `1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5`
  - 3 个页帧时缺页 9 次
  - 4 个页帧时缺页反而变成 10 次
- 产生原因：
  - FIFO 只考虑“进入顺序”，不考虑“访问频率”或“局部性”
  - 因此可能错误地淘汰了仍在工作集中的页

=== 最近最久未使用页面置换算法 (LRU, Least Recently Used)

*最近最久未使用算法的工作原理*
- 基本思路
  - 选择*最长时间没有被引用*的页面进行置换
  - 如某页面长时间未被访问，则它*在将来还可能*会长时间不会访问
- 算法实现
  - 缺页时，计算内存中每个逻辑页面的*上一次访问*时间
  - 选择上一次使用到当前时间最长的页面进行置换
- 算法特征
  - *最优置换算法的一种近似*

*最近最久未使用算法示例*
#figure(
  image("pic/2025-10-24-17-01-50.png", width: 80%),
  numbering: none,
)

*两种典型实现方式*
- LRU的页面链表实现
  - 页面链表
    - 系统维护一个*按最近一次访问时间排序的页面链表*
      - *链表首节点*是最近刚刚使用过的页面
      - *链表尾节点*是最久未使用的页面
    - 访问内存时，找到相应页面，并把它移到链表之首
    - 缺页时，置换链表尾节点的页面
  - 特征
    - 链表操作（移动节点）成本较高。
- LRU的活动页面栈实现
  - 活动页面栈
    - 访问页面时，将此*页号压入栈顶*，并栈内相同的页号抽出
    - 缺页时，*置换栈底*的页面
  - 特征
    - 更新时栈调整开销较大
#three-line-table[
  | 算法       | 思想        | 是否预知未来 | 实现复杂度  | 缺页率         | 是否出现 Belady 异常 |
  | -------- | --------- | ------ | ------ | ----------- | -------------- |
  | *OPT*  | 置换未来最久不访问 | ✅ 是    | ❌ 不可实现 | ⭐ 最低        | ❌ 不会           |
  | *FIFO* | 置换最早进入的页  | ❌ 否    | ✅ 简单   | ❌ 较高        | ✅ 可能           |
  | *LRU*  | 置换最近最久未用  | ❌ 否    | ⚙️ 中等  | ⭐ 较低（近似OPT） | ❌ 不会           |
]
#newpara()
*LRU的活动页面栈实现示例*
#figure(
  image("pic/2025-10-24-17-19-56.png", width: 80%),
  numbering: none,
)

=== 时钟页面置换算法 (Clock)

*时钟置换算法的工作原理*
- 基本思路
  - 仅对页面的访问情况进行*大致统计*
- 数据结构
  - 在页表项中增加*访问位*，描述页面在过去一段时间的内访问情况
  - 各页面组织成*环形链表*
  - 指针指向*最先调入的页面*
  - 在页表项（Page Table Entry）中增加两个标志位：
    #three-line-table[
      | 字段                  | 说明                        |
      | ------------------- | ------------------------- |
      | *驻留位 (R)*         | 表示页面是否在内存中（1=在，0=不在）      |
      | *访问位 (A)*         | 表示该页最近是否被访问过（1=访问过，0=未访问） |
      | *页帧号 (Frame No.)* | 映射的物理页号                   |
    ]
- 算法实现
  - *访问页面时*，在页表项记录页面访问情况
  - *缺页时*，从指针处开始顺序查找未被访问的页面进行置换
#figure(
  image("pic/2025-10-24-17-22-23.png", width: 40%),
  numbering: none,
)

*时钟置换算法的具体实现过程*
- 页面*装入内存时*，访问位初始化为0
- *访问页面（读/写)时*，访问位置1
- *缺页时*，从指针当前位置顺序检查
  - 访问位为0，则置换该页
  - 访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可置换的页面
- 算法特征
  - 时钟算法是LRU和FIFO的折中

*时钟置换算法示例*
#figure(
  image("pic/2025-10-24-22-44-27.png", width: 80%),
  numbering: none,
)

#three-line-table[
  | 特征          | 说明                                |
  | ----------- | --------------------------------- |
  | *思想来源*  | LRU 的近似实现                         |
  | *硬件支持* | 依赖页表项的访问位（A位）                     |
  | *优点*   | 实现简单，性能接近 LRU，系统开销小               |
  | *缺点*   | 无法精确反映访问的时间顺序，仅近似“最近最少使用”         |
  | *效果*   | 缺页率低于 FIFO，略高于 LRU；不会出现 Belady 异常 |
]

#three-line-table[
  | 算法        | 思想           | 开销 | 缺页率      | 是否出现 Belady 异常 |
  | --------- | ------------ | -- | -------- | -------------- |
  | *FIFO*  | 按进入顺序淘汰      | 低  | 高        | ✅ 会            |
  | *LRU*   | 淘汰最近最久未使用页   | 高  | 低        | ❌ 不会           |
  | *Clock* | 给被访问页“第二次机会” | 中  | 低（接近LRU） | ❌ 不会           |
]

=== 改进的时钟页面置换算法

*改进的时钟置换算法的工作原理*
- 基本思路
  - 减少*修改页*的缺页处理开销
  - 在置换页面时，优先选择“最近没被访问且没被修改”的页面，从而减少写回磁盘的开销
- 数据结构
  - 在页面中增加*修改位*，描述页面在过去一段时间的内写访问情况
  - 每个页表项包含三个关键标志位：
    #three-line-table[
      | 字段          | 含义                         |
      | ----------- | -------------------------- |
      | *驻留位 (R)* | 是否在内存中（1=在，0=不在）           |
      | *访问位 (A)* | 是否在最近一段时间被访问过（1=访问过，0=未访问） |
      | *修改位 (M)* | 是否被修改过（1=被写过，0=未修改）        |
    ]
- 算法实现
  - 访问页面时，在页表项记录页面访问情况
  - *修改页面时*，在页表项记录页面修改情况
  - 缺页时，修改页面标志位，以*跳过*有修改的页面

#figure(
  image("pic/2025-10-24-22-57-30.png", width: 80%),
  numbering: none,
)

*页面选择策略（四种类别）*
- 在缺页时，算法会多次扫描环，按以下优先级查找可替换页面：
  #three-line-table[
    | 扫描顺序 | 使用位 (A) | 修改位 (M) | 含义                        | 优先级     |
    | ---- | ------- | ------- | ------------------------- | ------- |
    | ①    | 0       | 0       | 未被访问 & 未被修改 → ✅ *最佳换出页* | 🥇 第一优先 |
    | ②    | 0       | 1       | 未被访问 & 被修改过 → 📦 需写回磁盘    | 🥈 第二优先 |
    | ③    | 1       | 0       | 被访问过 & 未修改 → 清除访问位，下次再考虑  | 🥉 第三优先 |
    | ④    | 1       | 1       | 被访问过 & 被修改 → 清除访问位，下次再考虑  | 🪶 最低优先 |
  ]
  如果在第一轮没找到 (0,0)，则会清零访问位，再重新扫描。

*改进的时钟置换算法示例*

#figure(
  image("pic/2025-10-24-22-59-21.png", width: 80%),
  numbering: none,
)

#three-line-table[
  | 特征          | 说明                             |
  | ----------- | ------------------------------ |
  | *优点*    | 减少磁盘写回次数，提高整体性能                |
  | *原理*   | 优先淘汰未被访问且未修改的页                 |
  | *实现*   | 使用 (A, M) 两位组合区分页面状态           |
  | *轮询机制* | 多次扫描环形队列（通常两轮）                 |
  | *效果*   | 兼顾“访问频率”与“写入成本”，性能接近 LRU，但开销更低 |
]
#three-line-table[
  | 算法                 | 依据            | 额外标志 | 特点        |
  | ------------------ | ------------- | ---- | --------- |
  | *FIFO*           | 调入顺序          | 无    | 实现简单，性能差  |
  | *LRU*            | 最近使用时间        | 需时间戳 | 性能优，但代价大  |
  | *Clock*          | 访问位 A         | 1位   | 近似 LRU    |
  | *Enhanced Clock* | 访问位 A + 修改位 M | 2位   | 减少写回，系统常用 |
]

=== 最不常用页面置换算法 (LFU, Least Frequently Used)

*最不常用算法的工作原理*
- 基本思路
  - 缺页时，置换*访问次数最少*的页面
- 算法实现
  - 每个页面设置一个*访问计数*
  - 访问页面时，*访问计数加1*
  - 缺页时，置换*计数最小的页面*
*最不常用算法特征*
- 特征
  - 算法开销大
  - 开始时频繁使用，但以后不使用的页面很难置换
    - 解决方法：计数定期右移
- LRU关注多久未访问，时间越短越好
- LFU关注访问次数，次数越多越好
*LFU示例*
- 4个物理页帧，最初的访问次数a-＞8 b-＞5 c-＞6 d-＞2
#figure(
  image("pic/2025-10-24-23-53-21.png", width: 80%),
  numbering: none,
)
#three-line-table[
  | 特性 | LRU         | LFU              |
  | -- | ----------- | ---------------- |
  | 依据 | 最近一次访问的时间   | 访问次数             |
  | 偏好 | 最近访问过的页面    | 经常被访问的页面         |
  | 优势 | 适合时间局部性强的程序 | 适合热点数据反复访问的程序    |
  | 缺陷 | 对周期性访问敏感    | 对阶段性访问不敏感（“冷却慢”） |
]

=== Belady现象

*Belady现象*
- 现象
  - 采用FIFO等算法时，可能*出现分配的物理页面数增加，缺页次数反而升高的异常现象*
- 原因
  - FIFO算法的置换特征与进程访问内存的动态特征*矛盾*
  - 被它置换出去的页面*并不一定*是进程近期不会访问的
- 思考
  - 哪些置换算法没有Belady现象？
    #three-line-table[
      | 算法              | 是否会出现 Belady 现象 | 原因              |
      | --------------- | --------------- | --------------- |
      | *FIFO*        | ✅ 会             | 按进入时间淘汰，与访问规律不符 |
      | *LRU*         | ❌ 不会            | 满足“堆栈性质”        |
      | *OPT（最优算法）*   | ❌ 不会            | 理论最优，缺页数最少      |
      | *Clock（时钟算法）* | 一般不会            | 近似 LRU，满足部分堆栈性质 |
      | *改进的 Clock*   | 一般不会            | 更接近 LRU         |
      | *LFU*         | 通常不会            | 基于访问频率，非先进先出逻辑  |
    ]
*FIFO算法的Belady现象*
- 访问顺序 : `1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5`
- 物理页面数: 3 ； 缺页次数: 9
  #figure(
    image("pic/2025-10-25-00-04-41.png", width: 80%),
    numbering: none,
  )
- 物理页面数: 4 ； 缺页次数: 10
  #figure(
    image("pic/2025-10-25-00-05-32.png", width: 80%),
    numbering: none,
  )
*LRU算法不存在Belady现象*
#figure(
  image("pic/2025-10-25-00-06-14.png", width: 80%),
  numbering: none,
)

*LRU、FIFO和Clock的比较*
- LRU算法和FIFO本质上都是先进先出的思路
  - LRU依据页面的*最近访问时间排序*
  - LRU需要动态地调整顺序
  - FIFO依据页面*进入内存的时间排序*
  - FIFO的页面进入时间是固定不变的
- LRU可退化成FIFO
  - 如页面进入内存后没有被访问，最近访问时间与进入内存的时间相同
  - 例如：给进程分配3个物理页面，逻辑页面的访问顺序为1、2、3、4、5、6、1、2、3…
- LRU算法性能较好，但系统开销较大
- FIFO算法系统开销较小，会发生Belady现象
- Clock算法是它们的*折衷*
  - 页面访问时，不动态调整页面在链表中的顺序，仅做标记
  - 缺页时，再把它移动到链表末尾
  - 对于*未被访问*的页面，Clock和LRU算法的表现一样好
  - 对于*被访问过*的页面，Clock算法不能记录准确访问顺序，而LRU算法可以
  #three-line-table[
    | 算法        | 依据     | 开销 | 是否有 Belady 现象 | 特点       |
    | --------- | ------ | -- | ------------- | -------- |
    | *FIFO*  | 页面进入时间 | 小  | ✅ 有           | 实现简单，性能差 |
    | *LRU*   | 最近访问时间 | 大  | ❌ 无           | 性能好，代价高  |
    | *Clock* | 访问位标记  | 中  | ❌ 无（近似）       | 折中方案     |
  ]

== 全局页面置换算法

#note(subname: [问题])[
  当系统中有多个进程同时运行时，如何从全局角度来分配和回收物理页帧。核心目标是：在保证系统稳定运行的前提下，使 CPU 利用率最大化、缺页率最小化。

  本节要解决两个关键问题
  #three-line-table[
    | 问题                              | 含义                               |
    | ------------------------------- | -------------------------------- |
    | *每个进程需要多少物理页帧？何时分配？*      | 若分配太少，会频繁缺页；分配太多，会浪费内存、影响并发。     |
    | *从系统整体角度看，应并发运行多少个进程最合适？* | 并发过多会导致“抖动（thrashing）”，反而降低系统效率。 |
  ]
  局部置换 vs 全局置换
  #three-line-table[
    | 类型         | 置换范围                  | 特点                  |
    | ---------- | --------------------- | ------------------- |
    | *局部页面置换* | 页面只能在*本进程*的页帧内置换    | 每个进程独立管理自己的页帧，不影响他人 |
    | *全局页面置换* | 页面可在*系统所有进程的页帧之间*置换 | 内存由全局统一分配，谁需要就从别人那抢 |
  ]
  在实际系统中，操作系统往往采用*“全局置换 + 局部限制”*的混合策略。

  关键思想：工作集与缺页率控制
  - 工作集算法（Working Set Model）
  - 缺页率算法（Page Fault Frequency, PFF）

]

=== 全局页面置换算法的定义

*全局页面置换算法*是指操作系统在发生缺页时，可以在系统所有进程的物理页帧中选择一个页面进行置换，而不仅限于当前进程的页帧范围

*局部置换算法没有考虑进程访存差异*
- FIFO 页面置换算法: 假设初始顺序 a->b->c
- 物理页面数: 3 缺页次数: 9
  #figure(
    image("pic/2025-10-25-00-19-40.png", width: 80%),
    numbering: none,
  )
- 物理页面数: 4 缺页次数: 1
  #figure(
    image("pic/2025-10-25-00-22-49.png", width: 80%),
    numbering: none,
  )
*全局置换算法的工作原理*
- 思路
  - *为进程分配可变数目的物理页面*
    - 当系统检测到某个进程缺页率过高时：
      - 可以从其他进程中收回一部分页帧
      - 再分配给该进程，以改善其性能
    - 当缺页率较低时：
      - 系统可减少该进程页帧数
      - 把资源让给更需要的进程
- 全局置换算法要解决的问题
  - 进程在*不同阶段*的内存需求是变化的
  - 分配给进程的*内存*也需要在*不同阶段有所变化*
  - 全局置换算法需要*确定分配给进程的物理页面数*

*全局置换算法要解决的核心问题*
- 如何确定每个进程所需的页帧数？
  - 不同阶段的访问特征不同（工作集大小变化）
  - 分配策略需随时间动态调整
- 何时为进程分配或回收物理页帧？
  - 根据缺页率、工作集变化或系统负载动态决定
- 如何在系统整体层面提高效率？
  - 既要保证每个进程正常运行
  - 又要防止系统过载导致“抖动（Thrashing）”

*CPU利用率与程序运行数量*
- CPU利用率与程序运行数量存在相互*促进和制约*的关系
  - 运行程序少时，提高程序运行数，可提高CPU利用率
  - 程序运行数量大导致内存访问增加，并会降低访存的局部性
  - 局部性下降会导致缺页率上升和CPU利用率下降

  #three-line-table[
    | 阶段   | 程序数量          | 系统表现                             |
    | ---- | ------------- | -------------------------------- |
    | 程序较少 | CPU 有空闲       | ✅ 适当增加并发进程，可提高 CPU 利用率           |
    | 程序过多 | 内存竞争严重        | ⚠️ 访存局部性下降，缺页率升高，CPU 大部分时间等待 I/O |
    | 抖动状态 | 缺页频繁，CPU 忙于换页 | ❌ CPU 利用率反而下降                    |
  ]

=== 工作集页面置换算法

*工作集*
- 一个进程在某个时刻$t$之前的一段时间（或访问次数）内，实际正在使用的逻辑页面集合称为该进程的工作集（Working Set）；可表示为二元函数$W(t, Delta)$
  - 当前执行时刻$t$：
  - 工作集窗口(working-set window)$Delta$：一个定长的页面访问时间窗口
  - 工作集窗口$Delta$的大小$tau$
    - 时间段长度，用当前时刻$t$前的内存访问次数来表示
  - 工作集$W(t, Delta)$
    - 在当前时刻$t$前的$Delta$时间窗口中的所有访问页面所组成的集合
  - 工作集大小$abs(W(t, Delta))$
    - 工作集中页面的数量

*工作集窗口的意义*
- $Δ$表示工作集窗口长度（Working-Set Window）
  - 它是一个“滑动窗口”，表示进程在最近 $Δ$ 次访问中用到的所有页面
- 工作集反映了进程的*局部性*特征
  - 窗口小：工作集小，但可能漏掉尚未换出的重要页面
  - 窗口大：工作集大，占用内存多，但能保证较低缺页率
- 因此 $Δ$ 的取值需要平衡内存开销与缺页频率

*进程的工作集示例*
- 示例访问序列：
  ```
  2 6 1 5 7 7 7 5 1 6 2 3 4 1 2 3 4 4 4 3 4 4 4 1 3 2 7
                   t1      t2                    t3
  ```
- 在时刻 t₁，Δ = 10
  - 工作集 W(t₁, Δ) = {1, 2, 5, 6, 7}
- 在时刻 t₂，Δ = 10
  - 工作集 W(t₂, Δ) = {1, 2, 3, 4, 5, 6, 7}
- 在时刻 t₃，Δ = 10
  - 工作集 W(t₃, Δ) = {3, 4}

*工作集的变化*
- *进程开始执行*后，随着访问新页面逐步建立较稳定的工作集
- 当内存访问的*局部性区域位置大致稳定*时，工作集大小也大致稳定
- *局部性区域位置改变*时，工作集快速扩张和收缩过渡到下一个稳定值
  #figure(
    image("pic/2025-10-25-00-52-51.png", width: 80%),
    numbering: none,
  )

*常驻集*
- 在当前时刻，进程*实际驻留内存*中的页面集合
  #three-line-table[
    | 概念      | 含义                      |
    | ------- | ----------------------- |
    | *工作集* | 进程在当前时刻所“需要”的页面集合（理论需求） |
    | *常驻集* | 实际在内存中驻留的页面集合（系统分配结果）   |
  ]
- 工作集与常驻集的关系
  - 工作集是进程在运行过程中的*固有性质*
  - 常驻集*取决于系统分配*给进程的物理页面数目和页面置换算法
- 缺页率与常驻集的关系
  - 常驻集 ⊇ 工作集时，缺页较少
  - 工作集发生剧烈变动（过渡）时，缺页较多
  - 进程常驻集大小达到一定数目后，缺页率也不会明显下降

*工作集页面置换算法*
- 思路
  - 换出*不在工作集中*的页面
- 工作集窗口大小τ
  - 当前时刻前τ次内存访问的页面集合构成*工作集*
- 实现方法
  - 访存链表：维护窗口内的访存页面链表
  - 访存时，*换出*不在工作集的页面，更新访存链表
  - 缺页时，换入页面，更新访存链表

  #three-line-table[
    | 操作       | 说明                         |
    | -------- | -------------------------- |
    | *访存链表* | 维护最近 Δ 次访问的页面（时间有序）        |
    | *页面访问* | 若页面在链表中 → 更新时间戳；若不在 → 加入链表 |
    | *页面置换* | 缺页时，换出链表中不在工作集窗口的最老页面      |
  ]

*工作集置换算法示例*
- $tau = 4$
#figure(
  image("pic/2025-10-25-01-30-21.png", width: 80%),
  numbering: none,
)

#three-line-table[
  | 特点     | 说明                 |
  | ------ | ------------------ |
  |  动态性 | 页帧数可随时间变化，反映进程实际需求 |
  |  适应性 | 能根据局部性变化调整分配       |
  |  效率  | 缺页率较低，系统稳定         |
  |  缺点  | 需维护时间窗口，系统开销大      |
]

=== 缺页率页面置换算法

*缺页率(Page-Fault-Frequency, Page Fault Rate)*
- 缺页次数 / 内存访问次数 或 缺页平均时间间隔的倒数
  $
    "PFF" = "缺页次数" / "内存访问次数" = 1 / "缺页平均时间间隔"
  $
  也就是说，缺页率越高，代表系统频繁地发生缺页异常，说明进程的物理页帧不足
- 影响缺页率的因素
  #three-line-table[
    | 因素       | 说明                           |
    | -------- | ---------------------------- |
    | 页面置换算法   | 算法越“聪明”，缺页率越低（如 LRU 优于 FIFO） |
    | 物理页帧数    | 页帧越多，能同时驻留的页面越多，缺页率下降        |
    | 页面大小     | 页面过大或过小都会影响换入换出的效率           |
    | 程序的访问局部性 | 局部性好的程序缺页率较低                 |
  ]

*缺页率置换算法*
- 通过调节*常驻集大小*，使每个进程的缺页率保持在一个合理的范围内
  - 若进程缺页率过高，则增加常驻集以分配更多的物理页面
  - 若进程缺页率过低，则减少常驻集以减少它的物理页面数

*缺页率页面置换算法*
- 访存时，为页面*设置*“引用位标志”（Reference Bit）
- 缺页发生时，记录当前时间`t_current`，并计算与上次缺页时间`t_last`的间隔：
  - `t_current - t_last > T`
    - 置换所有在`[t_last, t_current]`时间内没有被引用的页
  - `t_current - t_last < T`
    - 则增加缺失页到常驻集中

*缺页率置换算法示例*
- 假定窗口大小为 2
#figure(
  image("pic/2025-10-25-01-45-10.png", width: 80%),
  numbering: none,
)

#three-line-table[
  | 特点      | 说明                |
  | ------- | ----------------- |
  | 动态调整 | 依据缺页间隔，自动增加或减少页帧数 |
  | 精确控制 | 维持缺页率在理想区间        |
  | 实现简单 | 仅需记录“缺页时间间隔”      |
  | 缺点   | 不能精确反映工作集变化，反应滞后  |
]

#newpara()
*PFF 与工作集算法的比较*
- #three-line-table[
    | 对比项目 | 工作集算法       | 缺页率算法   |
    | ---- | ----------- | ------- |
    | 依据指标 | 时间窗口内的访问页集合 | 缺页时间间隔  |
    | 调整方式 | 维护工作集集合     | 调整常驻集大小 |
    | 实现开销 | 较大（需时间戳支持）  | 较小      |
    | 精确度  | 高，能反映局部性变化  | 相对滞后    |
    | 适用场景 | 精度要求高的系统    | 实时调节型系统 |
  ]

*抖动问题(thrashing)*
- 抖动
  - 进程*物理页面太少*，不能包含工作集
  - 造成*大量缺页*，频繁置换
  - 进程*运行速度变慢*
- 产生抖动的原因
  - 随着驻留内存的*进程数目*增加，分配给每个进程的物理页面数不断减小，缺页率不断上升
- 操作系统需在*并发水平和缺页率之间达到一个平衡*
  - 选择一个适当的进程数目和进程需要的物理页面数

#note(subname: [小结])[
  - 全局页面置换算法把所有进程视为整体来设置页面置换算法
    - 工作集置换算法、缺页率置换算法
  - 各层次存储介质均衡繁忙时，存储系统整体利用率最高
]
