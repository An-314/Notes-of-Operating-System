#import "@preview/scripst:1.1.1": *

= 操作系统概述

== 什么是操作系统

*操作系统*是管理硬件资源、控制程序运行、改善人机界面和为应用软件提供支持的一种系统软件。
- 操作系统是一个*资源管理程序*
  - 应用与硬件之间的*中间层*
  - 管理各种软硬件资源
  - 访问软硬件资源的服务
  - 解决访问冲突，确保公平使用
- 操作系统是一个*控制程序*
  - 一个系统软件
  - 执行程序，给程序提供服务
  - 控制程序执行过程，防止错误
  - 方便用户使用计算机系统

操作系统中的软件分类
- Shell – 命令行接口
- GUI – 图形用户接口
- Kernel – 操作系统的内部
- 软件
  - 应用软件
  - 系统软件
    - 系统应用
    - 操作系统
      - 命令行
      - 内核

#figure(
  image("pic/2025-09-15-16-26-02.png", width: 80%),
  caption: [uCore/rCore 教学操作系统内核],
)

操作系统内核的抽象
- CPU $<->$ 进程
- 磁盘 $<->$ 文件系统
- 内存 $<->$ 虚拟内存

操作系统内核的特征
- 并发：计算机系统中同时存在多个运行程序
- 共享：程序间“同时”访问互斥共享各种资源
- 虚拟：每个程序“独占”一台完整的计算机
- 异步：服务的完成时间不确定，也可能失败

操作系统设计理念
- 抽象：屏蔽硬件复杂性，提供统一接口。
- 资源管理：高效分配和调度有限资源。
- 隔离与保护：避免进程间干扰，保护系统安全。
- 并发与并行：支持多任务共享资源或并行运行。
- 透明性：隐藏底层复杂性，为用户提供一致体验。
- 可移植性：适应不同硬件平台，扩展应用场景。
- 简单性与模块化：降低复杂性，提高维护效率。

== 操作系统历史演化

- *单用户*系统 (1945-1955)
  - 手动*连线/纸带*传输进行程序输入
  - 机器成本远大于人力成本
  - 操作系统 = 装载器 + 程序库
  - 问题：昂贵组件的低利用率
- *批处理*系统 (1955-1965)
  - *磁带/磁盘*传输进行程序输入
  - 机器成本大于人力成本
  - 操作系统 = 装载器 + 程序控制器 + 输出处理器
  - 问题：相比以前利用率提高
- *多道程序*系统 (1955-1980)
  - 多个程序驻留*内存*中
  - 多个程序轮流使用 *CPU*
  - 操作系统 = 装载器 + *程序调度 + 内存管理* + 输出管理
  - 演变：相比以前利用率提高
- *分时*系统  (1970- 至今)
  - 多个程序驻留*内存*中
  - 多个程序分时使用 *CPU*
  - 操作系统 = 装载器 + 程序调度 + 内存管理 + *中断处理* +...
  - 演变：相比以前利用率提高、与外界交互延时缩短
常见的OS
- Multics OS
- Unix OS
- Linux 家族
- 个人电脑 (1981- )
  - 单用户
  - 计算机成本下降使CPU利用率不再是最重要的关注点
  - 重点是用户界面和多媒体功能
  - 操作系统 = 装载器 + 程序调度 + 内存管理 + 中断处理 +...
  - 演变：走向大众，老的服务和功能不存在，越来越多的安全问题
  - MacOS, Windows
- 分布式系统 (1990- )
  - 分布式多用户
  - 分布式系统利用率是关注点
  - 重点是网络/存储/计算的效率
  - 操作系统 = 分布式（装载器 + 程序/OS 调度 + 内存管理）
  - 演变：走向大众，走向网络，新的挑战 (不可靠/不确定)
- Android操作系统
  - 跨平台：支持Java应用程序
  - 运行时(runtime)：Android虚拟机
  - 应用框架：简化应用程序开发
- AIoT操作系统  (2000- )
  - 分布式多设备
  - 分布式系统利用率/可用性是关注点
  - 重点是网络/存储/计算的效率
  - 操作系统 = 分布式（程序/OS 调度 + 内存管理 + 安全/更新）
  - 演变：走向设备，走向网络，新的挑战 (不可靠/大数据)

== 操作系统结构

- 简单结构
  - MS-DOS：应用和OS混在一起 (1981–1994)
    - 没有拆分为模块
    - 主要用汇编编写
    - 没有安全保护
- 宏内核结构
  - 宏内核结构操作系统(Monolithic OS) 划分为多层 (levels)
    - 每层建立在低层之上
    - 最底层 (layer 0), 是硬件驱动
    - 最高层 (layer N) 是用户界面
    - 每一层仅使用更低一层的功能和服务
  #figure(
    image("pic/2025-09-18-10-41-28.png", width: 80%),
    numbering: none,
  )
- 微内核结构(Micro Kernel)
  - 尽可能把内核功能移到用户空间
  - 用户模块间的通信使用消息传递
  - 好处: 灵活/安全...
  - 缺点: 性能
  - LPC: 本地过程调用(Local Procedure Call)
  - HAL: 硬件抽象层（Hardware Abstraction Layer）
  #figure(
    image("pic/2025-09-18-10-42-58.png", width: 80%),
    numbering: none,
  )
- 外核结构(Exokernel)
  - 让内核分配物理资源给多个应用程序, 并让每个程序决定如何处理这些资源
  - 程序能链接到操作系统库 (libOS) 实现了操作系统抽象
  - 保护与控制分离
  - Distributed Shared Memory(DSM)
  #figure(
    image("pic/2025-09-18-10-45-51.png", width: 80%),
    numbering: none,
  )
- 虚拟机结构
  - 虚拟机管理器将单独的机器接口转换成很多的虚拟机, 每个虚拟机都是一个原始计算机系统的有效副本, 并能完成所有的处理器指令
  #figure(
    image("pic/2025-09-18-23-25-41.png", width: 80%),
    numbering: none,
  )

#note(subname: [小结])[
  - 操作系统架构：
    - 纵向分层
    - 横向隔离：虚拟存储、虚拟机
    - 依赖最小化：微内核、保护与控制分离
  - 平衡冲突操作系统实现目标
    - 折中：执行时间与存储空间
]

== 实践：试试UNIX/Linux

- UNIX/Linux提供哪些服务？
  - 进程（正在运行的程序）
  - 内存分配
  - 文件内容、文件名、目录
  - 访问控制（安全）
  - 许多其他的：用户、IPC、网络、时间
- UNIX/Linux提供的应用/内核接口？
  - APP $->$ C lib $->$ Syscall $->$ Kernel
  - 用C语言，来自类UNIX OS
    ```c
    fd = open("out", 1);
    write(fd, "hello\n", 6);
    ```
  看起来像函数调用，其实是系统调用
  - 核心的系统调用数量并不多
- UNIX/Linux提供的应用/内核接口？
#note(subname: [_Generated by GPT_])[

  系统调用是用户程序和操作系统内核之间的接口。*用户态程序不能直接访问硬件*，必须通过系统调用让内核代为完成。不同操作系统提供的系统调用集合不一样，但总体上可以分为几大类。

  1. *进程控制类*
    - 创建/终止/管理进程：
      - `fork()`：创建子进程
      - `execve()`：装入新程序
      - `exit()`：进程退出
      - `wait()` / `waitpid()`：等待子进程结束
      - `getpid()` / `getppid()`：获取进程 ID
    - 信号处理：
      - `kill()`：向进程发送信号
      - `sigaction()`：设置信号处理方式

  2. *文件管理类*
    - 打开/关闭文件：
      - `open()` / `openat()`
      - `close()`
    - 读写文件：
      - `read()`
      - `write()`
      - `lseek()`：移动文件指针
    - 文件属性：
      - `stat()` / `fstat()`：获取文件信息
      - `chmod()` / `chown()`：修改权限/所有者
      - `unlink()`：删除文件
  3. *目录与文件系统类*
    - `mkdir()` / `rmdir()`：创建/删除目录
    - `link()` / `symlink()`：创建硬链接/符号链接
    - `readlink()`：读取符号链接
    - `chdir()`：切换当前目录
    - `getcwd()`：获取当前目录
  4. *设备管理类*
    - `ioctl()`：设备控制（几乎所有特殊设备操作都靠它）
    - `mknod()`：创建设备文件
  5. *内存管理类*
    - `brk()` / `sbrk()`：调整数据段大小
    - `mmap()`：映射内存或文件到进程地址空间
    - `munmap()`：释放内存映射
  6. *通信类（IPC & 网络）*
    - *管道与消息*：
      - `pipe()`：创建匿名管道
      - `shmget()` / `shmat()` / `shmdt()`：共享内存
      - `msgget()` / `msgsnd()` / `msgrcv()`：消息队列
      - `semget()` / `semop()`：信号量
    - *Socket 网络*：
      - `socket()`
      - `bind()`
      - `listen()` / `accept()`
      - `connect()`
      - `send()` / `recv()`
      - `sendto()` / `recvfrom()`
  7. *时间与系统信息*
    - `time()`：获取当前时间
    - `gettimeofday()`：获取精确时间
    - `clock_gettime()`：高精度时钟
    - `uname()`：获取系统信息
    - `sysinfo()`：获取内存、负载等信息
  8. *用户管理*
    - `getuid()` / `geteuid()`：获取用户 ID
    - `setuid()`：切换用户身份
    - `getgid()` / `setgid()`：获取/设置组 ID



  Linux 提供了 *300+ 系统调用*（在 `unistd.h` 和 `syscall(2)` 手册里可查）。它们大致分为：*进程管理、文件管理、设备管理、内存管理、通信、信息服务、用户管理*七大类。

  *系统调用就是 操作系统的 API ，用户程序通过它才能操作文件、进程、内存、设备、网络等资源。*
]

具体的小程序应用见*HW2*。

#note(subname: [小结])[
  - 操作系统内核提供的系统调用服务
    - 资源访问：内存分配与释放、文件访问、外设访问
    - 进程管理：进程创建、暂停和退出
    - 通信服务：多种适合不同场景的通信机制
  - 为什么由操作系统内核提供这些特定的服务？
    - 共性服务
    - 多种目标的折中结果：由应用程序、内核或硬件来实现
]
