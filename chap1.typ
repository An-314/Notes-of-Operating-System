#import "@preview/scripst:1.1.1": *

= 操作系统概述

== 什么是操作系统

*操作系统*是管理硬件资源、控制程序运行、改善人机界面和为应用软件提供支持的一种系统软件。

#figure(
  image("pic/2025-09-20-14-17-47.png", width: 30%),
  numbering: none,
)

- 操作系统是一个*资源管理程序*
  - 应用与硬件之间的*中间层*
  - 管理各种软硬件资源
  - 访问软硬件资源的服务
  - 解决访问冲突，确保公平使用
- 操作系统是一个*控制程序*
  - 一个系统软件
  - 执行程序，给程序提供服务
  - 控制程序执行过程，防止错误
  - 方便用户使用计算机系统

操作系统中的软件分类
#grid(columns: (1fr, 1fr))[
  - Shell - 命令行接口
  - GUI - 图形用户接口
  - Kernel - 操作系统的内部
][
  #figure(
    image("pic/2025-09-20-14-19-46.png", width: 80%),
    numbering: none,
  )
]
#figure(
  image("pic/2025-09-20-14-18-50.png", width: 50%),
  numbering: none,
  caption: [操作系统内核的抽象],
)
操作系统内核的特征
- 并发：计算机系统中同时存在多个运行程序
- 共享：程序间“同时”访问互斥共享各种资源
- 虚拟：每个程序” 独占” 一台完整的计算机
- 异步：服务的完成时间不确定，也可能失败

#figure(
  image("pic/2025-09-15-16-26-02.png", width: 80%),
  caption: [uCore/rCore 教学操作系统内核],
)

操作系统内核的抽象
- CPU $<->$ 进程
- 磁盘 $<->$ 文件系统
- 内存 $<->$ 虚拟内存

操作系统内核的特征
- 并发：计算机系统中同时存在多个运行程序
- 共享：程序间“同时”访问互斥共享各种资源
- 虚拟：每个程序“独占”一台完整的计算机
- 异步：服务的完成时间不确定，也可能失败

操作系统设计理念
- 抽象：屏蔽硬件复杂性，提供统一接口。
- 资源管理：高效分配和调度有限资源。
- 隔离与保护：避免进程间干扰，保护系统安全。
- 并发与并行：支持多任务共享资源或并行运行。
- 透明性：隐藏底层复杂性，为用户提供一致体验。
- 可移植性：适应不同硬件平台，扩展应用场景。
- 简单性与模块化：降低复杂性，提高维护效率。

#note(subname: [小结])[
  - 操作系统是管理资源和提供服务的底层软件
  - 操作系统与应用软件的区别
    - 应用软件开发和运行所依赖的基础需要操作系统提供
    - 操作系统为应用软件提供运行环境和服务
  - 操作系统技术特征
    - 并发、共享、虚拟、异步
]

== 操作系统历史演化

- *单用户*系统 (1945-1955)
  - 手动*连线/纸带*传输进行程序输入
  - 机器成本远大于人力成本
  - *操作系统 = 装载器 + 程序库*
  - 问题：昂贵组件的低利用率
- *批处理*系统 (1955-1965)
  - *磁带/磁盘*传输进行程序输入
  - 机器成本大于人力成本
  - *操作系统 = 装载器 + 程序控制器 + 输出处理器*
  - 问题：相比以前利用率提高
- *多道程序*系统 (1955-1980)
  - 多个程序驻留*内存*中
  - 多个程序轮流使用 *CPU*
  - 操作系统 = 装载器 + *程序调度 + 内存管理* + 输出管理
  - 演变：相比以前利用率提高
- *分时*系统  (1970- 至今)
  - 多个程序驻留*内存*中
  - 多个程序分时使用 *CPU*
  - 操作系统 = 装载器 + 程序调度 + 内存管理 + *中断处理* +...
  - 演变：相比以前利用率提高、与外界交互延时缩短
常见的OS
- Multics OS
- Unix
- Linux 家族
- 个人电脑 (1981- )
  - 单用户
  - 计算机成本下降使CPU利用率不再是最重要的关注点
  - 重点是用户界面和多媒体功能
  - 操作系统 = 装载器 + 程序调度 + 内存管理 + 中断处理 +...
  - 演变：走向大众，老的服务和功能不存在，越来越多的安全问题
  - MacOS, Windows
- 分布式系统 (1990- )
  - 分布式多用户
  - 分布式系统利用率是关注点
  - 重点是网络/存储/计算的效率
  - 操作系统 = 分布式（装载器 + 程序/OS 调度 + 内存管理）
  - 演变：走向大众，走向网络，新的挑战 (不可靠/不确定)
- Android操作系统
  - 跨平台：支持Java应用程序
  - 运行时(runtime)：Android虚拟机
  - 应用框架：简化应用程序开发
- AIoT操作系统  (2000- )
  - 分布式多设备
  - 分布式系统利用率/可用性是关注点
  - 重点是网络/存储/计算的效率
  - 操作系统 = 分布式（程序/OS 调度 + 内存管理 + 安全/更新）
  - 演变：走向设备，走向网络，新的挑战 (不可靠/大数据)

#note(subname: [小结])[
  - 操作系统的发展历史
    - 单用户、批处理、多道、分时、Windows & macOS、分布式OS、IoT OS
  - 操作系统的历史演化方向
    - 提高性能：
      - 资源效率：中断、进程与调度、虚拟存储、同步互斥
      - 用户使用效率：GUI
      - 开发效率：可移植性C&Unix
    - 扩展应用范围：专用人员与普通用户、单机与分布式系统、计算机与数字化设备
]

== 操作系统结构

- 简单结构
  - MS-DOS：应用和OS混在一起 (1981–1994)
    - 没有拆分为模块
    - 主要用汇编编写
    - 没有安全保护
  #figure(
    image("pic/2025-09-20-14-12-38.png", width: 20%),
    numbering: none,
  )
- 宏内核结构
  - 宏内核结构操作系统(Monolithic OS) 划分为多层 (levels)
    - 每层建立在低层之上
    - 最底层 (layer 0), 是硬件驱动
    - 最高层 (layer N) 是用户界面
    - 每一层仅使用更低一层的功能和服务
  #figure(
    image("pic/2025-09-18-10-41-28.png", width: 80%),
    numbering: none,
  )
- 微内核结构(Micro Kernel)
  - 尽可能把内核功能移到用户空间
  - 用户模块间的通信使用消息传递
  - 好处: 灵活/安全...
  - 缺点: 性能
  - LPC: 本地过程调用(Local Procedure Call)
  - HAL: 硬件抽象层（Hardware Abstraction Layer）
  #figure(
    image("pic/2025-09-18-10-42-58.png", width: 50%),
    numbering: none,
  )
- 外核结构(Exokernel)
  - 让内核分配物理资源给多个应用程序, 并让每个程序决定如何处理这些资源
  - 程序能链接到操作系统库 (libOS) 实现了操作系统抽象
  - 保护与控制分离
  - Distributed Shared Memory(DSM)
  #figure(
    image("pic/2025-09-18-10-45-51.png", width: 50%),
    numbering: none,
  )
- 虚拟机结构
  - 虚拟机管理器将单独的机器接口转换成很多的虚拟机, 每个虚拟机都是一个原始计算机系统的有效副本, 并能完成所有的处理器指令
  #figure(
    image("pic/2025-09-18-23-25-41.png", width: 50%),
    numbering: none,
  )

#note(subname: [小结])[
  - 操作系统架构：
    - 纵向分层
    - 横向隔离：虚拟存储、虚拟机
    - 依赖最小化：微内核、保护与控制分离
  - 平衡冲突操作系统实现目标
    - 折中：执行时间与存储空间
]

== 实践：试试UNIX/Linux

- Try UNIX/Linux
  - shell
    - bash 基本的shell环境
    - fish 强调交互性和可用性
    - zsh 带有自动补全、支持插件
    - ...
  - program
    - ls, cp, mv, rm, gcc, gdb, vim ...
- UNIX/Linux提供哪些服务？
  - 进程（正在运行的程序）
  - 内存分配
  - 文件内容、文件名、目录
  - 访问控制（安全）
  - 许多其他的：用户、IPC、网络、时间
- UNIX/Linux提供的应用/内核接口？
  - APP $->$ C lib $->$ Syscall $->$ Kernel
  - 用C语言，来自类UNIX OS
    ```c
    fd = open("out", 1);
    write(fd, "hello\n", 6);
    ```
  看起来像函数调用，其实是系统调用
  - 核心的系统调用数量并不多
- UNIX/Linux提供的应用/内核接口？
#note(subname: [UNIX/Linux提供的应用/内核接口 _Generated by GPT_])[

  系统调用是用户程序和操作系统内核之间的接口。*用户态程序不能直接访问硬件*，必须通过系统调用让内核代为完成。不同操作系统提供的系统调用集合不一样，但总体上可以分为几大类。

  1. *进程控制类*
    - 创建/终止/管理进程：
      - `fork()`：创建子进程
      - `execve()`：装入新程序
      - `exit()`：进程退出
      - `wait()` / `waitpid()`：等待子进程结束
      - `getpid()` / `getppid()`：获取进程 ID
    - 信号处理：
      - `kill()`：向进程发送信号
      - `sigaction()`：设置信号处理方式

  2. *文件管理类*
    - 打开/关闭文件：
      - `open()` / `openat()`
      - `close()`
    - 读写文件：
      - `read()`
      - `write()`
      - `lseek()`：移动文件指针
    - 文件属性：
      - `stat()` / `fstat()`：获取文件信息
      - `chmod()` / `chown()`：修改权限/所有者
      - `unlink()`：删除文件
  3. *目录与文件系统类*
    - `mkdir()` / `rmdir()`：创建/删除目录
    - `link()` / `symlink()`：创建硬链接/符号链接
    - `readlink()`：读取符号链接
    - `chdir()`：切换当前目录
    - `getcwd()`：获取当前目录
  4. *设备管理类*
    - `ioctl()`：设备控制（几乎所有特殊设备操作都靠它）
    - `mknod()`：创建设备文件
  5. *内存管理类*
    - `brk()` / `sbrk()`：调整数据段大小
    - `mmap()`：映射内存或文件到进程地址空间
    - `munmap()`：释放内存映射
  6. *通信类（IPC & 网络）*
    - *管道与消息*：
      - `pipe()`：创建匿名管道
      - `shmget()` / `shmat()` / `shmdt()`：共享内存
      - `msgget()` / `msgsnd()` / `msgrcv()`：消息队列
      - `semget()` / `semop()`：信号量
    - *Socket 网络*：
      - `socket()`
      - `bind()`
      - `listen()` / `accept()`
      - `connect()`
      - `send()` / `recv()`
      - `sendto()` / `recvfrom()`
  7. *时间与系统信息*
    - `time()`：获取当前时间
    - `gettimeofday()`：获取精确时间
    - `clock_gettime()`：高精度时钟
    - `uname()`：获取系统信息
    - `sysinfo()`：获取内存、负载等信息
  8. *用户管理*
    - `getuid()` / `geteuid()`：获取用户 ID
    - `setuid()`：切换用户身份
    - `getgid()` / `setgid()`：获取/设置组 ID



  Linux 提供了 *300+ 系统调用*（在 `unistd.h` 和 `syscall(2)` 手册里可查）。它们大致分为：*进程管理、文件管理、设备管理、内存管理、通信、信息服务、用户管理*七大类。

  *系统调用就是 操作系统的 API ，用户程序通过它才能操作文件、进程、内存、设备、网络等资源。*
]

#link("https://pdos.csail.mit.edu/6.828/2021/lec/l-overview/")[MIT的6.828课程讲义]中给出了一些系统调用的示例

- `open()`
  - `open()` 创建一个文件，返回一个文件描述符（File Descriptor，简称FD，或-1表示错误）
  - FD是正整数，代表一个打开的文件
- `read()`和`write()`
  - `read()`/`write()`第一个参数是"文件描述符"(`fd`)，传递给内核，告诉它要读/写哪个"打开的文件"
  - 一个文件描述符对应一个打开的文件
  - 一个进程可以打开许多文件，有许多描述符
  - 缺省情况：
    - 文件描述符`0`是 "标准输入", 通常是键盘
    - 文件描述符`1`是 "标准输出"，通常是显示器
  - `read()`第二个参数是指向要读取的缓冲区的指针，缓冲区的大小由第三个参数指定
  - 文件访问模式：`open -> read/write -> close`
- `fork()`系统调用创建一个进程的副本（子进程）
  - 复制：指令、数据、寄存器、文件描述符、当前目录
  - 形成"父 "和 "子 "进程
  #figure(
    image("pic/2025-09-20-13-58-07.png", width: 80%),
    numbering: none,
  )
  - 区别：`fork()`在父进程中返回一个`pid`，在子进程中返回`0`
    - `pid`（进程ID）是一个整数，内核给每个进程一个不同的`pid`
    - 因此，`fork.c`中父子进程的`fork()`返回值`pid`不同
    - 父子进程的执行差别就体现在对`fork()`返回值`pid`的判别上
      - `0`代表子进程，否则代表父进程
- `exec()`系统调用用一个新程序替换当前进程的映像
  - 在这个进程中运行一个新程序，用一个可执行文件代替调用进程
  - 丢弃已有指令和数据内存空间
  - 从文件中加载新执行程序的指令和数据
- `forkexec()`
  - `fork()`一个新进程，`exec()`一个程序
  - 常见的UNIX APP执行模式
    - `fork()`：创建子进程
    - `exec()`：子进程中执行新程序
    - `wait()`：父进程等待子进程完成
    - `exit()`：进程退出
    #figure(
      image("pic/2025-09-20-14-02-48.png", width: 80%),
      numbering: none,
    )
- `redirect()`
  - 重定向一个命令的输出
  - 缺省情况下，文件描述符为`1`的文件是屏幕输出
  - `open()`总是选择值最小的未使用的文件描述符
  - 通过 `close(1) + open(...)`操作，设定`"output.txt"`的文件描述符为`1`
  - `exec(...)`系统调用保留了文件描述符，执行`echo`命令后，它的屏幕输出将被重定向到`"output.txt"`
- `pipe2()`
  - shell的管道机制`|`，把一个命令的输出作为另一个命令的输入
  - `pipe()`系统调用创建了两个`fd`
    - `fd[0]`用于读取，`fd[1]`用于写入
    #figure(
      image("pic/2025-09-20-14-05-12.png", width: 80%),
      numbering: none,
    )

更多具体的系统调用应用的小程序见*HW2*。

#note(subname: [UNIX/Linux 系统调用机制])[
  1. *文件描述符 (FD) 与 open/read/write*
    - 程序要访问文件，必须通过 `open()` 打开，内核返回一个 *文件描述符*（整数）。
    - 后续所有的 `read()`/`write()` 都通过这个 FD 进行，而不是直接用文件名。
    - 默认约定：
      - `0` → 标准输入（键盘）
      - `1` → 标准输出（显示器）
      - `2` → 标准错误（错误输出）
  2. *进程创建与替换*
    - `fork()`：复制当前进程，得到一个子进程（父子进程几乎完全相同，但 `fork()` 返回值不同）。
    - `exec()`：把当前进程的“内容”换成新程序，但 PID 不变。
    - 常见用法是 `fork() + exec()`：父进程创建子进程，子进程执行新程序，父进程用 `wait()` 等待子进程完成。
  3. *I/O 重定向与管道*
    - 通过操作 FD，可以实现输出重定向，例如把 `stdout (1)` 改到文件。
    - `pipe()` 可以建立进程间通信，把一个进程的输出连到另一个进程的输入（shell 中的 `|`）。
]

#note(subname: [一些问题的回答 _Generated by GPT_])[
  这些问题本质上是*操作系统设计的哲学*，上面的例子希望你去思考为什么 UNIX 选择了这些抽象，而不是别的方案：

  1. *为什么抽象成 I/O 和进程？*
    - UNIX 提供了少量、统一的抽象：文件和进程。
    - 这样所有设备都可以看作文件（磁盘、终端、管道），大大简化了 API。
  2. *为什么有文件系统，而不是让程序直接操控磁盘？*
    - 文件系统提供了命名、权限、安全和一致性。
    - 如果每个程序都直接读写磁盘块，就没有共享和隔离的保障。
  3. *为什么用 FD 而不是文件名？*
    - 文件名是字符串，效率低；而 FD 是整数，方便索引内核中的“打开文件表”。
    - FD 还能让不同进程共享（继承）已打开的文件，而不仅仅是文件路径。
  4. *为什么文件是字节流，而不是磁盘块或记录？*
    - 字节流更通用，不依赖具体的硬件或应用格式。
    - 上层应用（数据库、文本编辑器）可以自由定义结构，而不是被内核强制。

  5. *为什么不把 `fork()` 和 `exec()` 合在一起？*
    - 分开设计更灵活：可以在 `fork()` 和 `exec()` 之间修改环境（比如重定向 FD、设置信号处理）。
    - 也方便写一些特殊程序（比如父子进程同时继续执行同一个程序）。

  *UNIX 的设计不是唯一的*
]

#note(subname: [小结])[
  - 操作系统内核提供的系统调用服务
    - 资源访问：内存分配与释放、文件访问、外设访问
    - 进程管理：进程创建、暂停和退出
    - 通信服务：多种适合不同场景的通信机制
  - 为什么由操作系统内核提供这些特定的服务？
    - 共性服务
    - 多种目标的折中结果：由应用程序、内核或硬件来实现
]
