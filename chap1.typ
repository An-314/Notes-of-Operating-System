#import "@preview/scripst:1.1.1": *

= 操作系统概述

== 什么是操作系统

*操作系统*是管理硬件资源、控制程序运行、改善人机界面和为应用软件提供支持的一种系统软件。
- 操作系统是一个*资源管理程序*
  - 应用与硬件之间的*中间层*
  - 管理各种软硬件资源
  - 访问软硬件资源的服务
  - 解决访问冲突，确保公平使用
- 操作系统是一个*控制程序*
  - 一个系统软件
  - 执行程序，给程序提供服务
  - 控制程序执行过程，防止错误
  - 方便用户使用计算机系统

操作系统中的软件分类
- Shell – 命令行接口
- GUI – 图形用户接口
- Kernel – 操作系统的内部
- 软件
  - 应用软件
  - 系统软件
    - 系统应用
    - 操作系统
      - 命令行
      - 内核

#figure(
  image("pic/2025-09-15-16-26-02.png", width: 80%),
  caption: [uCore/rCore 教学操作系统内核],
)

操作系统内核的抽象
- CPU $<->$ 进程
- 磁盘 $<->$ 文件系统
- 内存 $<->$ 虚拟内存

操作系统内核的特征
- 并发：计算机系统中同时存在多个运行程序
- 共享：程序间“同时”访问互斥共享各种资源
- 虚拟：每个程序“独占”一台完整的计算机
- 异步：服务的完成时间不确定，也可能失败

操作系统设计理念
- 抽象：屏蔽硬件复杂性，提供统一接口。
- 资源管理：高效分配和调度有限资源。
- 隔离与保护：避免进程间干扰，保护系统安全。
- 并发与并行：支持多任务共享资源或并行运行。
- 透明性：隐藏底层复杂性，为用户提供一致体验。
- 可移植性：适应不同硬件平台，扩展应用场景。
- 简单性与模块化：降低复杂性，提高维护效率。

== 操作系统历史演化

- *单用户*系统 (1945-1955)
  - 手动*连线/纸带*传输进行程序输入
  - 机器成本远大于人力成本
  - 操作系统 = 装载器 + 程序库
  - 问题：昂贵组件的低利用率
- *批处理*系统 (1955-1965)
  - *磁带/磁盘*传输进行程序输入
  - 机器成本大于人力成本
  - 操作系统 = 装载器 + 程序控制器 + 输出处理器
  - 问题：相比以前利用率提高
- *多道程序*系统 (1955-1980)
  - 多个程序驻留*内存*中
  - 多个程序轮流使用 *CPU*
  - 操作系统 = 装载器 + *程序调度 + 内存管理* + 输出管理
  - 演变：相比以前利用率提高
- *分时*系统  (1970- 至今)
  - 多个程序驻留*内存*中
  - 多个程序分时使用 *CPU*
  - 操作系统 = 装载器 + 程序调度 + 内存管理 + *中断处理* +...
  - 演变：相比以前利用率提高、与外界交互延时缩短
常见的OS
- Multics OS
- Unix OS
- Linux 家族
- 个人电脑 (1981- )
  - 单用户
  - 计算机成本下降使CPU利用率不再是最重要的关注点
  - 重点是用户界面和多媒体功能
  - 操作系统 = 装载器 + 程序调度 + 内存管理 + 中断处理 +...
  - 演变：走向大众，老的服务和功能不存在，越来越多的安全问题
  - MacOS, Windows
- 分布式系统 (1990- )
  - 分布式多用户
  - 分布式系统利用率是关注点
  - 重点是网络/存储/计算的效率
  - 操作系统 = 分布式（装载器 + 程序/OS 调度 + 内存管理）
  - 演变：走向大众，走向网络，新的挑战 (不可靠/不确定)
- Android操作系统
  - 跨平台：支持Java应用程序
  - 运行时(runtime)：Android虚拟机
  - 应用框架：简化应用程序开发
- AIoT操作系统  (2000- )
  - 分布式多设备
  - 分布式系统利用率/可用性是关注点
  - 重点是网络/存储/计算的效率
  - 操作系统 = 分布式（程序/OS 调度 + 内存管理 + 安全/更新）
  - 演变：走向设备，走向网络，新的挑战 (不可靠/大数据)

== 操作系统结构

- 简单结构
  - MS-DOS：应用和OS混在一起 (1981–1994)
    - 没有拆分为模块
    - 主要用汇编编写
    - 没有安全保护
- 宏内核结构
  - 宏内核结构操作系统(Monolithic OS) 划分为多层 (levels)
    - 每层建立在低层之上
    - 最底层 (layer 0), 是硬件驱动
    - 最高层 (layer N) 是用户界面
    - 每一层仅使用更低一层的功能和服务
  #figure(
    image("pic/2025-09-18-10-41-28.png", width: 80%),
    numbering: none,
  )
- 微内核结构(Micro Kernel)
  - 尽可能把内核功能移到用户空间
  - 用户模块间的通信使用消息传递
  - 好处: 灵活/安全...
  - 缺点: 性能
  - LPC: 本地过程调用(Local Procedure Call)
  - HAL: 硬件抽象层（Hardware Abstraction Layer）
  #figure(
    image("pic/2025-09-18-10-42-58.png", width: 80%),
    numbering: none,
  )
- 外核结构(Exokernel)
  - 让内核分配物理资源给多个应用程序, 并让每个程序决定如何处理这些资源
  - 程序能链接到操作系统库 (libOS) 实现了操作系统抽象
  - 保护与控制分离
  - Distributed Shared Memory(DSM)
  #figure(
    image("pic/2025-09-18-10-45-51.png", width: 80%),
    numbering: none,
  )
- 虚拟机结构
  - 虚拟机管理器将单独的机器接口转换成很多的虚拟机, 每个虚拟机都是一个原始计算机系统的有效副本, 并能完成所有的处理器指令

== 实践：试试UNIX/Linux

- UNIX/Linux提供的应用/内核接口？
  - APP -> C lib -> Syscall -> Kernel
  - 用C语言，来自类UNIX OS
    ```C
    fd = open("out", 1);
    write(fd, "hello\n", 6);
    ```
  看起来像函数调用，其实是系统调用
  - 核心的系统调用数量并不多
- 小结
  - 操作系统内核提供的系统调用服务
    - 资源访问：内存分配与释放、文件访问、外设访问
    - 进程管理：进程创建、暂停和退出
    - 通信服务：多种适合不同场景的通信机制
  - 为什么由操作系统内核提供这些特定的服务？
    - 共性服务
    - 多种目标的折中结果：由应用程序、内核或硬件来实现
