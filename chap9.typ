#import "@preview/scripst:1.1.1": *

= 文件系统

== 文件和文件系统

#note(subname: [问题])[
  - 作为存储介质，内存与硬盘有什么区别？
    #three-line-table[
      | 对比项 | 内存（RAM）           | 硬盘（HDD/SSD）           |
      | --- | ----------------- | --------------------- |
      | 速度  | 极快（纳秒级）           | 较慢（毫秒级 HDD / 微秒级 SSD） |
      | 持久性 | *断电即失*（易失性）     | *断电也保存*（非易失性）       |
      | 作用  | CPU直接访问，运行程序、数据缓存 | 长期存储文件和系统数据           |
      | 成本  | 单位容量更贵            | 更便宜                   |
      | 容量  | 相对较小              | 大容量                   |
    ]
  - 你了解的文件是什么样的？
    - 通俗地说：文件 = 一段持久保存的数据 + 名字
    - 在操作系统视角，文件具有这些特性
      - 存储在磁盘等长期介质上
      - 有名字、有路径（用来访问）
      - 有长度、权限、时间戳等属性
      - 被视为一个字节流（对应用程序透明）
      - 是操作系统文件系统管理的对象
    - 常见文件类型
      #three-line-table[
        | 类别   | 示例             | 特点         |
        | ---- | -------------- | ---------- |
        | 普通文件 | .txt .jpg .exe | 数据或程序      |
        | 目录   | /home/xx       | 存储文件名和路径关系 |
        | 特殊文件 | /dev/sda       | 设备抽象       |
      ]
  - 持续保存数据如何组织？
    - 为了把数据稳妥地放在磁盘上、还找得到，操作系统做了组织规划：
      - 分配磁盘空间（文件存哪里）
      - 索引定位（如何快速找到）
      - 目录结构（文件怎么组织）
      - 访问权限（谁能操作）
      - 元数据管理（大小时间属性等）
      - 保证可靠性（断电崩溃不丢文件）
    - 典型数据组织方式
      #three-line-table[
        | 组织方式          | 思路        | 说明         |
        | ------------- | --------- | ---------- |
        | 线性连续存储        | 连续磁盘块     | 读写快但容易碎片化  |
        | 链式存储          | 每块指向下一块   | 查找可能慢      |
        | 索引存储（如 inode） | 独立索引指向数据块 | 现代文件系统主流方式 |
      ]
      实际文件系统常用 inode + 数据块，比如 EXT4、XFS、Unix FS
]

=== 文件

==== 文件的概念

*什么是文件系统？*
- 文件系统是存储设备上组织文件的*方法和数据结构*
  #figure(
    image("pic/2025-11-05-22-43-48.png", width: 80%),
    numbering: none,
  )
- 文件系统是操作系统中负责文件命名、存储和检索的*子系统*
  #figure(
    image("pic/2025-11-05-22-46-17.png", width: 80%),
    numbering: none,
  )

*什么是文件？*
- 文件是具有符号名，由字节序列构成的*数据项集合*
  - 文件是文件系统的基本*数据单位*
- *文件名*是文件的标识符号
- *文件头*：文件系统元数据中的文件信息
  - 文件属性：名称、类型、位置、创建时间、…
  - 文件存储位置和顺序
  #three-line-table[
    | 项           | 解释                         |
    | ----------- | -------------------------- |
    | 文件本质        | 字节序列（OS不关心内容格式）            |
    | 文件名         | 标识符（给人看的，不一定对应物理位置）        |
    | 文件头（inode等） | 文件元数据：记录大小、位置、权限等          |
    | 文件属性        | 名称、类型、长度、位置、创建/访问/修改时间、权限… |
  ]

*一切都是文件*
- UNIX类操作系统的设计哲学：*一切皆文件*
  - 普通文件，目录文件
  - 字符设备文件（如键盘，鼠标...）
  - 块设备文件（如硬盘，光驱...）
  - 网络文件（socket ...）等等
  #three-line-table[
    | 类型      | 示例                |
    | ------- | ----------------- |
    | 普通文件    | \*.txt, \*.c, \*.bin |
    | 目录文件    | `/home/user/`     |
    | 字符设备文件  | 键盘、鼠标 `/dev/tty`  |
    | 块设备文件   | 磁盘 `/dev/sda`     |
    | 网络文件    | socket            |
    | 管道、FIFO | 进程间通信             |
  ]
- 所有一切均抽象成文件，提供了*统一的接口*，方便应用程序调用
  - `read() / write() / open() / close()`

*文件视图*
- *用户的文件视图*
  - 持久存储的数据结构
  - 系统调用接口：*字节序列*的集合(UNIX)
- *操作系统的文件视图*
  - *数据块*的集合
  - 数据块是逻辑存储单元，而*扇区*是物理存储单元
*文件中数据的内部结构*
- 与应用相关
  - 无结构：文本文件
  - 简单结构：CSV、JSON等格式化文件
  - 复杂结构：Word文件、ELF可执行文件

==== 文件操作

*文件的基本操作*
- 进程*读文件*
  - 获取文件所在的数据块
  - 返回数据块内对应部分
- 进程*写文件*
  - 获取数据块
  - 修改数据块中对应部分
  - 写回数据块
  #figure(
    image("pic/2025-11-05-22-59-33.png", width: 80%),
    numbering: none,
  )
  - CPU 并不会直接对磁盘读写，磁盘→内存缓冲区→用户进程 是标准路径
  - 即使程序只写 1 byte，文件系统一般也要操作 4KB 的块；所以 `getc()/putc()` 虽看起来是字节操作，本质是块级操作 + 缓冲优化

*文件的基本操作单位*
- 文件系统中的基本操作单位是*数据块*
  - 例如，`getc()`和`putc()`即使每次只访问1字节的数据，也需要缓存目标数据4096字节
  #three-line-table[
    | 名称        | 含义         | 示例          |
    | --------- | ---------- | ----------- |
    | 扇区 Sector | 磁盘物理最小单位   | 512B or 4KB |
    | 块 Block   | 文件系统逻辑最小单位 | 通常 4KB      |
    | 字节 Byte   | 应用层最小单位    | 1B          |
  ]
  内核通过页面缓存 Page Cache来减少磁盘访问

*文件的访问模式*
- 顺序访问: 按字节依次读取
  - 把一维数据映射到文件中
- 随机访问: 从任意位置读写
  - 把一个复杂结构(矩阵)映射到文件中
- 索引访问: 依据数据特征索引
  - 数据库访问是一种基于索引的访问

*文件访问控制*
- 多用户操作系统中的*文件共享*是很必要的
- 访问控制
  - 用户对文件的访问权限
  - 读、写、执行、删除
- 文件访问控制列表(ACL-Access Control List)
  - `<文件实体, 权限>`更精细，现代系统如 NTFS 支持
- UNIX模式
  - `<用户|组|所有人, 读|写|可执行>`
  - 用户标识ID
  - 组标识ID

*多进程如何访问共享文件？*
- 文件是一类共享资源
  - 需要互斥访问
  - 采用类似的同步互斥技术
    - 读写锁
  #three-line-table[
    | 类型         | 解释          |
    | ---------- | ----------- |
    | 互斥锁        | 防止并发修改      |
    | 读写锁 RWLock | 多读单写        |
    | 文件锁 flock  | POSIX 文件锁接口 |
  ]

==== 文件描述符

*应用程序如何访问文件？*
- 应用访问文件数据前必须先“打开”文件，获得*文件描述符*
- 再进一步通过文件描述符（File Descriptor，fd）读写文件
  ```
  fd = open(name, flag);
  read(fd, …);
  close(fd);
  ```

*文件描述符* 当应用程序请求内核打开/新建一个文件时，内核返回一个文件描述符用于*对应这个打开/新建的文件*。
- 形式上，文件描述符是一个*非负整数*
- 实际上，文件描述符是一个*索引值*，指向内核为每一个进程所维护的该进程打开文件的记录表
  #figure(
    image("pic/2025-11-05-23-09-53.png", width: 80%),
    numbering: none,
  )

*打开文件表*
- 内核*跟踪*进程打开的所有文件
  - 操作系统为*每个进程*维护一个打开的文件描述符表
  - 一个*系统级*的打开文件表
  - *i-node*表指中向具体的文件内容
  #three-line-table[
    | 层级          | 内容             | 说明            |
    | ----------- | -------------- | ------------- |
    | *进程打开文件表* | 文件描述符 & 文件指针   | 每个进程自己维护，fd索引 |
    | *系统打开文件表* | 文件状态、访问模式、打开计数 | 所有进程共享        |
    | *inode 表* | 文件元数据与磁盘地址     | 指向真实文件数据块     |
  ]
- 内核在*打开文件表*中*维护打开文件状态和信息*
  - 文件指针
    - 最近一次读写位置
    - 每个进程分别维护自己的打开文件指针
  - 文件打开计数
    - 当前打开文件的次数
    - 最后一个进程关闭文件时，将其从打开文件表中移除
  - 文件的磁盘位置
    - 缓存数据访问信息
  - 访问权限
    - 每个进程的文件访问模式信息
  #three-line-table[
    | 信息            | 存储位置  | 作用             |
    | ------------- | ----- | -------------- |
    | 文件指针 (offset) | 进程级   | 记录读写位置         |
    | 访问模式 (R/W/X)  | 系统级   | 管权限            |
    | 打开计数          | 系统级   | 引用计数，最后一个关闭才释放 |
    | 缓存/磁盘位置       | inode | 文件数据在哪         |
  ]
*默认文件描述符*
- UNIX 系统启动时自动打开三个文件：
  #three-line-table[
    | fd | 名称     | 含义       |
    | -- | ------ | -------- |
    | 0  | stdin  | 标准输入（键盘） |
    | 1  | stdout | 标准输出（屏幕） |
    | 2  | stderr | 错误输出（屏幕） |
  ]

=== 文件系统和文件组织

==== 文件系统的功能

*文件系统类型*
- #three-line-table[
    | 类别         | 示例                                      | 特点               |
    | ---------- | --------------------------------------- | ---------------- |
    | 磁盘文件系统     | FAT32, NTFS, ext2/ext3/ext4, ISO9660    | 本地磁盘/光盘文件存储      |
    | 网络/分布式文件系统 | NFS, SMB, AFS, GFS, Ceph                | 多机器共享文件          |
    | 特殊文件系统     | procfs (`/proc`), sysfs (`/sys`), tmpfs | 不存真实文件，内核接口或内存文件 |
  ]
  - `procfs` 就像内核数据的“假文件书架”
  - `sysfs` 是系统设备和驱动的窗口
  - `tmpfs` 放在内存里，速度快
*虚拟文件系统 (VFS)*
- VFS 是一个抽象层，用来统一不同文件系统接口
- 它屏蔽底层差异，使 Linux 能同时访问 ext4、NFS、FAT、devfs 等
  #figure(
    image("pic/2025-11-05-23-17-53.png", width: 80%),
    numbering: none,
  )

*文件系统功能*
- 文件系统是操作系统中*管理持久性数据的子系统*，提供数据文件*命名、存储和检索*功能
  - 组织、检索、读写访问数据
  - 大多数计算机系统都有文件系统
- 分配文件磁盘空间
  - 管理文件块（位置和顺序）
  - 管理空闲空间(位置)
  - 分配算法 (策略)
- 管理文件集合
  - 组织：组织文件的控制结构和数据结构
  - 命名：给文件取名字
  - 定位：通过名字找到文件文件及其内容
- 数据可靠和安全
  - 安全：多层次保护数据安全
  - 可靠
    - 持久保存文件
    - 避免系统崩溃、数据丢失等

*文件系统组织结构*
- 分层/树状目录结构
  - 文件以目录的方式组织起来
  - *目录*是一类特殊的文件
  - 目录的内容是文件索引表`<文件名, 指向文件的指针>`
  ```
  /
  ├── bin
  ├── home
  │   └── user
  └── etc
      ├── config.cfg
      └── hosts
  ```

==== 目录

*目录操作*
- 应用程序通过系统调用对目录进行操作
  - 搜索文件
  - 创建文件
  - 删除文件
  - 列目录
  - 重命名文件
- 目录就是*文件名 → 文件位置（inode）*的映射表，本质上是个「索引簿」
  #three-line-table[
    | 操作   | 示例                   |
    | ---- | -------------------- |
    | 搜索文件 | `open("a.txt")` 会查目录 |
    | 创建文件 | `creat()`            |
    | 删除文件 | `unlink()`           |
    | 列目录  | `ls`                 |
    | 重命名  | `mv old new`         |
  ]
*目录实现方式*
- 文件名的*线性列表*，包涵了指向数据块的指针
  - 编程简单、执行耗时
- 哈希表 – 哈希数据结构的线性表
  - 减少目录搜索时间
  - 可能有冲突 - 两个文件名的哈希值相同
- ext2/3 传统用线性扫描，ext4 和 XFS 支持哈希索引提升性能
  ```
  目录文件内容（简化）
  [name1 → inode#12]
  [name2 → inode#8]
  [name3 → inode#109]
  ```

*路径解析（遍历目录）*
- 解析 `./fs/inode.rs`
  - 读取 `.` 当前目录
  - 找到 `fs` 项 → 得到 `fs` 的 inode
  - 读取 `fs` 目录内容
  - 找到 `inode.rs` → 得到目标文件 `inode`
  - 进入 `inode` → 获取数据
- 所以访问文件不是跳一次，是逐级查目录。
  - Linux 内核有目录项缓存（dentry cache）避免重复解析

*文件别名（多个名字指同一文件）*
- 多个文件名关联同一个文件
- 硬链接(hard link)
  - 多个文件项指向一个文件
- 软链接(soft link, symbolic link)
  - 新建文件，以存储文件名称的方式来指向其他文件
- inode：管理文件数据的结构
  #three-line-table[
    | 类型             | 指向          | 是否跨文件系统 | 链到目录 | 删除原文件后的结果   |
    | -------------- | ----------- | ------- | ---- | ----------- |
    | 硬链接 hard link  | 指向同一个 inode | ❌       | ❌    | 文件仍存在       |
    | 符号链接 soft link | 指向路径字符串     | ✅       | ✅    | 链断掉，变“悬空链接” |
  ]
  ```
  ln a.txt b.txt      # 硬链接
  ln -s a.txt link    # 软链接
  ```
  #figure(
    image("pic/2025-11-05-23-25-36.png", width: 80%),
    numbering: none,
  )
- 硬链接是对一个文件的引用，而软链接则是一个指向文件路径的指针
- *硬链接不能跨文件系统*，也不能链接到目录
  - 避免目录循环，所以不能链接到目录
- *软链接可以跨文件系统*，也可以链接到目录
- 如何避免目录中没有形成循环？
  - 只允许对文件的链接，不允许对子目录的链接
  - 增加链接时，用循环检测算法确定是否合理
  - 限制遍历文件目录的路径数量

*文件系统挂载*
- 文件系统需要先挂载才能被访问
  - 挂载(mount)是将一个文件系统连接到现有目录树的过程
  ```
  mount /dev/sdb1 /mnt/data
  ```

== 文件系统的设计与实现

#note(subname: [问题])[
  - 如何高效地管理和访问磁盘上存储的文件？
    - 文件系统要解决：
      #three-line-table[
        | 目标   | 说明              |
        | ---- | --------------- |
        | 定位文件 | 目录结构、inode、路径解析 |
        | 快速访问 | 数据结构、缓存、预读、写回   |
        | 节省空间 | 空闲空间管理、分配策略     |
        | 可靠性  | 崩溃恢复、写日志、元数据保护  |
        | 安全性  | 权限、ACL、隔离       |
        | 一致性  | 保证元数据和文件系统结构不乱  |
      ]
    - 实现方式包括：
      - 目录管理（哈希树、B+树、dentry cache）
      - 块管理（位图、链式、索引）
      - 磁盘数据布局（inode table、superblock）
      - 缓存机制（page cache、buffer cache）
      - 写策略（异步写、写回、日志 journaling）
      - VFS 抽象层
  - 内存管理方法可以借用来管理文件吗？
    - 能借，但不能直接照搬
      #three-line-table[
        | 内存概念          | 文件概念                     | 借鉴点           |
        | ------------- | ------------------------ | ------------- |
        | 页 Page        | 块 Block                  | 固定大小管理，提高定位效率 |
        | 页表 Page Table | inode 索引                 | 多级索引结构        |
        | TLB           | dentry cache/inode cache | 加缓存加速查找       |
        | 段 Segment     | 文件                       | 分模块组织、权限控制    |
      ]
]

=== 概述

*文件系统的分层结构*
#figure(
  image("pic/2025-11-05-23-33-20.png", width: 80%),
  numbering: none,
)
- VFS 是“翻译官”，上接统一接口，下接各种真实文件系统
*文件系统在计算机系统中的分层结构*
#figure(
  image("pic/2025-11-05-23-33-52.png", width: 70%),
  numbering: none,
)
*文件系统的用户视图与内核视图*
#figure(
  image("pic/2025-11-05-23-34-08.png", width: 80%),
  numbering: none,
)
#figure(
  image("pic/2025-11-05-23-34-34.png", width: 80%),
  numbering: none,
)
- inode 结构包含：
  - 文件元信息（权限、时间戳、大小）
  - 数据块指针（直接/间接）
- 数据真正放在数据块区

*虚拟文件系统* VFS, Virtual File System

- 一组所有文件系统都支持的数据结构和标准接口
- 磁盘的文件系统：直接把数据存储在磁盘中
  - 比如 Ext 2/3/4、XFS
- 内存的文件系统：内存辅助数据结构
  - 例如目录项
  #three-line-table[
    | 功能       | 解释                                |
    | -------- | --------------------------------- |
    | 统一接口     | 对用户永远是 open/read/write            |
    | 统一抽象     | inode、dentry、file 对象              |
    | 文件系统插件框架 | ext4, FAT, NFS 像插件一样挂进去           |
    | 高速缓存     | inode cache + dentry cache 提升查找速度 |
  ]
- 虚拟文件系统的功能
  - 目的：对所有不同文件系统的抽象
  - 功能
    - 提供相同的文件和文件系统*接口*
    - 管理所有文件和文件系统关联的*数据结构*
    - 高效*查询*例程：遍历文件系统
    - 与特定文件系统模块的交互

=== 文件系统的基本数据结构

*文件系统的存储视图*
- 文件卷控制块 (`superblock`)
- 文件控制块(`inode/vnode`)
- 目录项 (`dir_entry`)
- 数据块（`data block`）
  #figure(
    image("pic/2025-11-05-23-38-21.png", width: 80%),
    numbering: none,
  )

#three-line-table[
  | 名称               | 作用              | 类比          |
  | ---------------- | --------------- | ----------- |
  | Superblock（卷控制块） | 整个文件系统的元信息      | 图书馆“总目录”    |
  | Inode（文件控制块）     | 具体文件的元信息        | 书籍的“目录卡”    |
  | Dir entry（目录项）   | 文件名 → inode 的映射 | 架位标签“书名→卡号” |
  | Data block（数据块）  | 真正的数据内容         | 书架上的书页      |
]
```
vol → root dir → 子目录 → 文件 → 数据块
```
#figure(
  image("pic/2025-11-18-17-03-21.png", width: 80%),
  numbering: none,
)
ext 系列的典型布局：
```
Superblock
Inode Bitmap   # 哪些 inode 被占用
Data Bitmap    # 哪些 block 被占用
Inode Table    # 文件元信息 index node
Data Blocks    # 真实文件数据
```
目录项不会单独有表，它存放在 Data Block 里（目录也是文件）

#figure(
  image("pic/2025-11-18-17-14-25.png", width: 80%),
  numbering: none,
)

*文件卷控制块`superblock`*
- 每个文件系统一个文件卷控制块
  - 块大小、空余块数量等
  - block与inode 的总量，未使用与已使用的数量
  - filesystem的挂载时间、最近一次写入时间、最近一次检验磁盘(fsck) 时间
- ```rust
  pub struct Superblock {
    magic: u32,               // 文件系统类型标识
    pub total_blocks: u32,    // 总块数
    pub inode_bitmap_blocks: u32, // inode 位图占用块数
    pub inode area_blocks: u32,   // inode 区块数
    pub data_bitmap_blocks: u32,  // 数据位图占用块数
    pub data_area_blocks: u32,    // 数据区块数
  }
  ```
*文件控制块`inode`*
- 每个文件有一个文件控制块 inode (`inode`/`vnode`)
  - 大小、数据块位置（指向一个或多个datablock）
  - 访问模式(read/write/excute)
  - 拥有者与群组(owner/group)
  - 时间信息：建立或状态改变的时间、最近读取时间/修改的时间
  - *文件名存放在目录的datablock*
  - 文件的字节数
  - 文件拥有者的 User ID
  - 文件的 Group ID
  - 链接数：有多少文件名指向这个 inode
  - 文件数据 block 的位置（直接、间接）
- ```rust
  pub struct DiskInode {
    pub size: u32,               // 文件大小（字节）
    pub direct: [u32; INODE_DIRECT_COUNT], // 直接数据块指针
    pub indirect1: u32,         // 一级间接块指针
    pub indirect2: u32,         // 二级间接块指针
    type: DiskInodeType,        // 文件类型
  }
  ```
*bitmap块 `bitmap inode/dnode`*
- inode使用或者未使用标志位
- dnode使用或者未使用标志位
- 用于空间分配
*数据块dnode(`data node`)*
- 目录和文件的数据块
  - 放置目录和文件内容
  - 格式化时确定data block的固定大小
  - 每个block都有编号，以方便inode记录
  - inode一般为128B
  - data block一般为4KB
- 目录的数据块存：
  #three-line-table[
    | Inode 号 | 类型   | 文件名       |
    | ------- | ---- | --------- |
    | 2       | 目录   | .         |
    | 1       | 目录   | ..        |
    | 18      | 文件   | hello.txt |
    | 19      | 插图文件 | a.png     |
  ]
  这其实是一张表文件 inside 文件
  #figure(
    image("pic/2025-11-18-17-38-31.png", width: 80%),
    numbering: none,
  )
*目录项(`dir_entry`)*
- 一个目录（文件夹）包含多个目录项
  - 每个目录项一个(目录和文件)
  - 将目录项数据结构及树型布局编码成树型数据结构
  - 指向文件控制块、父目录、子目录等
- OS会缓存一个读过目录项来提升效率
- ```rust
  pub struct DirEntry {
    name: [u8, NAME_LENGTH_LIMIT + 1], // 文件名
    inode_number: u32,               // 指向的 inode 号
  }
  ```

=== 文件缓存

*多种磁盘缓存位置*
#figure(
  image("pic/2025-11-18-17-44-51.png", width: 80%),
  numbering: none,
)
```
磁盘
  ↓
磁盘控制器：扇区缓存（硬件级别）
  ↓
内存：
   - 数据块缓存 buffer cache
   - 页缓存 page cache
   - 打开文件表
   - 内存虚拟磁盘（RAMFS、tmpfs）
```
#newpara()
*数据块缓存（Block Cache / Buffer Cache）*
- 数据块*按需读入*内存
  - 提供`read()`操作
  - 预读: 预先读取后面的数据块
- 数据块使用后被*缓存*
  - 假设数据将会再次用到
  - 写操作可能被缓存和延迟写入
  #figure(
    image("pic/2025-11-18-17-54-18.png", width: 80%),
    numbering: none,
  )
这是文件系统使用的“传统缓存方式”。
- 作用
  - 按需把文件的数据块读到内存（read）
  - 可能预读（read-ahead）
  - 使用后会暂存，以便下次快速访问
  - 写操作可能延迟写入（write-back）
- 方式如下：
  - 按需读取（On-demand read）
    - 当进程调用 `read(fd, ...)`：
    - 内核检查缓存里是否有对应的数据块
    - 如果没有，就从磁盘读入内存
    - 返回给用户
  - 预读机制（Readahead）
    - 如果用户读取第 1 块，内核很可能自动把第 2 块、3 块也读入。
    - 因为大多数程序都以顺序访问为主。
  - 写操作延迟写（Delayed write）
    - `write()` 的数据通常不立刻写到磁盘，而是写到缓存里，并标记为 dirty（脏块），稍后再统一写回。
    - 好处：
      - 减少磁盘写次数（合并一堆写成一次）
      - 程序运行更快
    - 代价：
      - 系统崩溃可能导致数据丢失，因此有 journal/log 机制加持（ext4、XFS）

*页缓存（Page Cache）*
- 页缓存: 统一缓存数据块和内存页
- 在虚拟地址空间中虚拟页面可映射到本地外存文件中
  #figure(
    image("pic/2025-11-18-17-58-27.png", width: 80%),
    numbering: none,
  )
- 文件数据块的页缓存
  - 在虚拟内存中文件数据块被映射成页
  - 文件的读/写操作被转换成对内存的访问
  - 可能导致缺页和/或设置为脏页
- 问题: 页置换算法需要协调虚拟存储和页缓存间的页面数

*文件描述符（File Descriptor）*
- 每一个被打开的文件，都需要：
  - 一个文件描述符（用户态编号）
  - 一个进程打开文件表 entry
  - 一个系统文件表 entry（跨进程共享）
  - 一个 inode
- 每个被打开的文件都有一个文件描述符作为index，指向对应文件状态信息
- 打开文件表
  - 每个进程1个进程打开文件表
  - 一个系统打开文件表
  ```
  进程打开文件表（用户级 FD）
        ↓
  系统打开文件表（open file）
        ↓
  inode（文件元数据）
        ↓
  数据块数据
  ```
  #figure(
    image("pic/2025-11-18-18-21-09.png", width: 80%),
    numbering: none,
  )

*文件锁*
- 一些文件系统提供文件锁，用于协调多进程的文件访问
  - 强制：根据锁保持情况和访问需求确定是否拒绝访问
  - 劝告：进程可以查找锁的状态来决定怎么做

=== 文件分配

*文件大小*
- 大多数文件都很小
  - 需要支持小文件
  - 数据块空间不能太大
- 一些文件非常大
  - 能支持大文件
  - 可高效读写

*文件分配*
- 分配文件数据块
- 分配方式
  - 连续分配
  - 链式分配
  - 索引分配
- 评价指标
  - 存储效率：外部碎片等
  - 读写性能：访问速度

==== 连续分配（Contiguous Allocation）

文件占用磁盘上一段连续的物理块：
#figure(
  image("pic/2025-11-18-18-31-14.png", width: 80%),
  numbering: none,
)
```
文件头：
  起始块号 + 长度（占用多少个连续块）
```
- 分配策略: 最先匹配, 最佳匹配, ...
- 优点：高效的顺序和随机读访问
- 缺点：频繁分配会带来碎片；增加文件内容开销大

==== 链式分配（Linked Allocation）

每个数据块都有指向“下一个数据块”的指针：
#figure(
  image("pic/2025-11-18-18-31-50.png", width: 80%),
  numbering: none,
)
```
块2 → 块7 → 块3 → 块9 → 块14 → ...
```
- 优点: 创建、增大、缩小很容易；几乎没有碎片
- 缺点：
  - 随机访问效率低；可靠性差；
  - 破坏一个链，后面的数据块就丢了

*显式链式（FAT）*
- 所有的链表关系放在一张表 FAT 中：
  ```
  FAT[2] = 7
  FAT[7] = 3
  FAT[3] = 9
  ...
  ```
  目录项只需要知道开始块号。
  #figure(
    image("pic/2025-11-18-18-33-31.png", width: 80%),
    numbering: none,
  )

*隐式链式（链在每个数据块里）*
- 每个块保存了指向下一块的指针
  ```
  数据 | next-block-number
  ```

==== 索引分配（Indexed Allocation）

- 文件头包含了*索引数据块指针*
- 索引数据块中的索引是文件数据块的指针
#figure(
  image("pic/2025-11-18-18-34-25.png", width: 80%),
  numbering: none,
)
```
索引块：
  [5, 7, 9, 14, ...]
```
- 优点
  - 创建、增大、缩小很容易；几乎没有碎片；支持直接访问
- 缺点
  - 当文件很小时，存储索引的开销相对大

索引分配
- 链式索引块(IB+IB+…)
  #figure(
    image("pic/2025-11-18-18-35-23.png", width: 80%),
    numbering: none,
  )
- 多级索引块(IB\*IB\*…)
  #figure(
    image("pic/2025-11-18-18-35-32.png", width: 80%),
    numbering: none,
  )

#figure(
  image("pic/2025-11-18-18-35-42.png", width: 80%),
  numbering: none,
)

*多级索引（UNIX inode）*
- UNIX（ext2/3/4）文件系统采用：
  - 10 个直接块指针（存小文件）
  - 1 个一级间接块指针
  - 1 个二级间接块指针
  - 1 个三级间接块指针
#figure(
  image("pic/2025-11-18-18-36-21.png", width: 80%),
  numbering: none,
)

可以支持非常大的文件
- 例如：块大小 4KB；每个指针 4B，则一个索引块能存：
  ```
  4KB / 4B = 1024 个指针
  ```
- 一级间接块可寻址：
  - $1024$ 个数据块 = 4MB
- 二级间接块：
  - $1024 × 1024$ = 1M 个数据块 = 4GB
- 三级间接块：
  - $1024^3$ ≈ $10^9$ 块 = 4TB

#three-line-table[
  | 方式                   | 优点          | 缺点              |
  | -------------------- | ----------- | --------------- |
  | *连续分配*             | 顺序 & 随机访问最快 | 外部碎片，文件增长困难     |
  | *链式分配（隐式/显式 FAT）*  | 扩展容易，无碎片    | 随机访问很慢；可靠性差（链断） |
  | *索引分配（inode 多级索引）* | 支持随机访问，易扩展  | 索引块需要空间；多级寻址稍慢  |
]

==== 空闲空间管理（Free Space Management）

跟踪记录文件卷中未分配的数据块

*位图（bitmap）*
- ```
  111110001011011 ...
  1=已占用
  0=空闲
  ```
- 160GB磁盘 --> 40M数据块 --> 5MB位图
- 假定空闲空间在磁盘中均匀分布，
  - 找到“0”之前要扫描$n/r$
    - $n$磁盘上数据块的总数
    - $r$空闲数据块的比例
*链表*
#figure(
  image("pic/2025-11-18-18-39-57.png", width: 80%),
  numbering: none,
)
*索引*
#figure(
  image("pic/2025-11-18-18-40-03.png", width: 80%),
  numbering: none,
)

=== 文件访问过程示例

*文件系统组织示例*
#figure(
  image("pic/2025-11-18-18-41-14.png", width: 80%),
  numbering: none,
)
- inode 位图（inode bitmap）
  - 每一位对应一个 inode 是否被使用
  - 找空闲 inode 就是在找“0”位
- 数据块位图（data bitmap）
  - 每一位对应一个数据块是否被使用
  - 找空闲数据块也是找“0”
- inode 区（inodes）
  - 每个 inode 保存：
    - 文件大小
    - 文件类型（文件/目录/链接）
    - 数据块指针（direct, indirect）
    - 权限属性等
- 数据块区（data blocks）
  - 存放文件内容
  - 或目录项（文件名 + inode 号）
  - 或间接索引块
- 根目录 inode -> 目录数据块 -> 子目录 inode …
  - 文件系统层级通过目录数据块里的“文件名 → inode号”来链接。
*文件读操作过程*
#figure(
  image("pic/2025-11-18-18-42-41.png", width: 80%),
  numbering: none,
)
```
路径解析 → 找到 inode → 查看 inode 的数据块指针 → 查找缓存 →
  命中 → 直接返回
  未命中 → 读磁盘 → 放入缓存 → 返回数据
```
#newpara()
*文件写操作过程*
#figure(
  image("pic/2025-11-18-18-45-58.png", width: 80%),
  numbering: none,
)
```
路径解析 → 找到/创建 inode → 分配数据块 → 写入缓存 →
  标记脏页 → 延迟写回磁盘
```
#newpara()
*文件系统分区*
- 多数磁盘划分为一个或多个分区，每个分区有一个独立的文件系统
  #figure(
    image("pic/2025-11-18-18-46-25.png", width: 80%),
    numbering: none,
  )
磁盘被分为多个分区 (partition)
- 每个分区包含一个完整的文件系统，结构如下：
- 引导块（boot block）
  - 仅第一个分区用来装引导程序（如 GRUB）
- 超级块（superblock）
  - 整个文件系统的元数据
  - 总 inode 数
  - 总数据块数
  - 块大小
  - 空闲块统计
  - 空闲 inode 统计
  非常关键，损坏会导致文件系统不可用
- 块组描述符（Block Group Descriptor）
  - 记录每个块组的 bitmap、inode 区等偏移
- 位图（inode bitmap & data bitmap）
  - 管理空闲 inode / 数据块
- inode 列表
  - 每个 inode 是一个结构体
- 数据块区
  - 存放实际文件内容、目录内容等

== 支持崩溃一致性的文件系统

#note(subname: [问题])[
  如何减少文件系统中的数据丢失和出错机率？

  *为什么会发生文件系统损坏？*
  - 文件系统进行写操作时，必须修改多个不同的数据结构。例如写入一个新文件需要：
    - 修改数据块内容（data block）
    - 更新 inode（文件元数据：大小、时间戳、指向的数据块等）
    - 更新数据位图（标记数据块已被占用）
    - 更新 inode 位图（新 inode 被分配）
    - 更新目录项（目录文件添加新条目）
  - 这些写入顺序必须严格遵守，否则就会产生不一致（inconsistency）。

  *崩溃时可能产生的错误*
  - 设想在写文件过程中断电或 OS 崩溃，会出现以下问题：
    - 数据丢失 Data Loss
      - 例如还没把缓存中的脏页刷到磁盘 → 文件内容丢失
    - 元数据不一致 Metadata Inconsistency

  *文件系统崩溃后如何恢复？*
  - FSCK（文件系统检查）
    - 早期 UNIX/ext2 的恢复方法。
  - 日志文件系统（Journaling File System）
    - 典型：ext3/ext4，NTFS，XFS，ReiserFS
  - 写时复制（Copy-on-Write, COW）
    - 典型：Btrfs，ZFS，APFS（苹果的文件系统）
]

=== 崩溃一致性问题

==== 崩溃一致性

*文件系统的持久数据更新挑战*
- 如何在出现断电（power loss）或系统崩溃（system crash）的情况下，更新持久数据结构？
- 崩溃可能导致磁盘文件系统映像中的文件系统数据结构出现*不一致*性。如，有空间泄露、将垃圾数据返回给用户等.

*崩溃一致性问题*
- *崩溃一致性问题*（crash-consistency problem）也称一致性更新问题（consistent-update problem）
- 特定操作需要更新磁盘上的两个结构A和B。
- 磁盘一次只为一个请求提供服务，因此其中一个请求将首先到达磁盘（A或B），而另一个没写到磁盘。
- 如果在一次写入完成后系统崩溃或断电，则磁盘上的结构将处于不一致（inconsistent）的状态。

*崩溃一致性的需求*
- 目标
  - 将文件系统从一个一致状态（在文件被追加之前），原子地（atomically）*变迁*到另一个一致状态（在inode、位图和新数据块被写入磁盘之后）。
- 困难
  - 磁盘一次只提交一次写入，更新之间可能会发生崩溃或断电。

*文件更新过程示例*
- 考虑一个应用以某种方式更新磁盘结构：将单个数据块附加到原有文件。
  - 通过打开文件，调用`lseek()`将文件偏移量移动到文件末尾，然后在关闭文件之前，向文件发出单个4KB写入来完成追加。
  - lseek + write 并非原子操作。多个进程可能在 lseek 和 write 之间修改文件，导致偏移量失效。

*文件系统数据结构*
- inode位图（inode bitmap，只有8位，每个inode一个）
- 数据位图（data bitmap，也是8位，每个数据块一个）
- inode（总共8个，编号为0到7，分布在4个块上）
- 数据块（总共8个，编号为0～7）。
#figure(
  image("pic/2025-11-18-18-59-27.png", width: 80%),
  numbering: none,
)

*文件更新中的磁盘操作*
- 考虑一个应用以某种方式更新磁盘结构：将单个数据块附加到原有文件
  - 必须对磁盘执行*3次单独写入*
    - inode（I[v2]）、位图（B[v2]）和数据块（Db）
  - 发出`write()`系统调用时，这些写操作通常不会立即发生。
    - 脏的inode、位图和新数据先在*内存*（页面缓存page cache，或缓冲区缓存buffer cache）中存在一段时间。
  - 当文件系统最终决定将它们写入磁盘时（比如说5s或30s），文件系统将向磁盘发出必要的*写入请求*。

==== 崩溃场景

*文件操作中的崩溃*
- 在文件操作过程中可能会发生崩溃，从而干扰磁盘的这些更新。
- 如果写入操作中的一个或两个完成后发生崩溃，而不是全部3个，则文件系统可能处于有趣（不一致）的状态。

#figure(
  image("pic/2025-11-18-19-01-58.png", width: 80%),
  numbering: none,
)

*崩溃场景一*：只将数据块（Db）写入磁盘
- 数据在磁盘上，但没有指向它的inode，也没有表示块已分配的位图
- 好像写入从未发生过一样
- 这是空间泄露（leak），未来永远无法回收
*崩溃场景二*：只有更新的inode（I[v2]）写入了磁盘
- inode指向磁盘块5，其中Db即将写入，但Db尚未写入
- 从磁盘读取垃圾数据（磁盘块5的旧内容）
- 这是数据损坏（stale / garbage data）
*崩溃场景三*：只有更新后的位图（B[v2]）写入了磁盘
- 位图指示已分配块5，但没有指向它的inode
- 这种写入将导致空间泄露（space leak），文件系统永远不会使用块5
- 结果：空间泄露（leak）
*崩溃场景四*：inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）
- inode有一个指向块5的指针，位图指示5正在使用
- 因此从文件系统的元数据的角度来看，一切看起来很正常
- 但磁盘块5中又是垃圾数据
*崩溃场景五*：写入了inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）
- inode指向了磁盘上的正确数据
- 在inode和位图（B1）的旧版本之间存在*不一致*
- 触发双重使用（double allocation），文件系统可能互相覆盖
*崩溃场景六*：写入了位图（B[v2]）和数据块（Db），但没有写入inode（I[v2]）
- inode和数据位图之间再次存在不一致
- 不知道它属于哪个文件，因为没有inode指向该块

#three-line-table[
  | 场景 | 写入情况           | 错误类型       |
  | -- | -------------- | ---------- |
  | 1  | 仅 data block   | 空间泄露       |
  | 2  | 仅 inode        | 用户读到垃圾     |
  | 3  | 仅 data bitmap  | 空间泄露       |
  | 4  | inode + bitmap | 用户读到垃圾     |
  | 5  | inode + data   | 双重分配（严重错误） |
  | 6  | bitmap + data  | 空间泄露       |
]

=== 文件系统检查程序 fsck

*崩溃解决方案*
- 文件系统检查程序 fsck
- 基于预写日志（write ahead log）的文件系统

*文件系统检查程序 fsck*
- 早期的文件系统采用了一种简单的方法来处理崩溃一致性
- 让不一致的事情发生，然后再修复它们（重启时）
- 目标：确保文件系统元数据内部一致

*超级块检查*
- 检查超级块检查是否合理，主要是进行健全性检查
  - 确保文件系统大小大于分配的块数
  - 找到超级块的*内容不合理（冲突）*，系统（或管理员）可以决定使用超级块的*备用副本*
- 注：可靠性高的文件系统，会有多处放置超级块备份的磁盘扇区
  #figure(
    image("pic/2025-11-18-19-08-49.png", width: 80%),
    numbering: none,
  )
*位图与inode间的一致性检查*
- 扫描inode、间接块、双重间接块等，以了解当前在文件系统中分配的块，生成正确版本的分配位图
- 如果位图和inode之间存在任何不一致，则通过*信任inode内的信息*来解决它
- 对所有inode执行相同类型的检查，确保所有看起来像在使用的inode，都在inode位图中有标记
inode状态检查
*inode状态检查*
- 检查每个inode是否存在损坏或其他问题
- 每个分配的inode具有有效的类型字段（即常规文件、目录、符号链接等）
- 如果inode字段存在问题，不易修复，则inode被认为是可疑的，并被fsck清除，inode位图相应地更新。
*链接计数检查*
- inode链接计数表示包含此特定文件的引用（即链接）的不同目录的数量。
- 从根目录开始扫描整个目录树，并为文件系统中的每个文件和目录构建自己的链接计数
- 如果*新计算的计数*与inode中找到的计数不匹配，则通常是修复inode中的计数
- 如果发现已分配的inode但*没有目录引用*它，则会将其移动到lost + found目录。
*重复指针检查*
- 两个不同的inode引用同一个块的情况
- 如果一个inode明显错误，可能会被清除或复制指向的块，从而为每个inode提供其自己的文件数据
- inode有很多错误可能性，比如其inode内的元数据不一致
  - inode有文件的长度记录，但其实际指向的数据块大小小于其文件长度
*坏块检查*
- 在扫描所有指针列表时，检查坏块指针。如果指针显然指向超出其有效范围的某个指针，则该指针被认为是“坏的”。
  - 地址指向大于分区大小的块
  - 从inode或间接块中删除（清除）该指针
*目录检查*
- fsck不了解用户文件的内容，但目录包含由文件系统本身创建的特定格式的信息。对每个目录的内容执行额外的完整性检查。
  - 确保“.”和“..”是前面的条目，目录条目中引用的每个inode都已分配
  - 确保整个层次结构中没有目录的引用超过一次
*文件系统检查程序 fsck 的不足*
- 对于非常大的磁盘卷，扫描整个磁盘，以查找所有已分配的块并读取整个目录树，可能需要几分钟或几小时。
- 可能丢数据！


=== 日志文件系统
