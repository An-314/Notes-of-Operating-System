#import "@preview/scripst:1.1.1": *

= 文件系统

== 文件和文件系统

#note(subname: [问题])[
  - 作为存储介质，内存与硬盘有什么区别？
    #three-line-table[
      | 对比项 | 内存（RAM）           | 硬盘（HDD/SSD）           |
      | --- | ----------------- | --------------------- |
      | 速度  | 极快（纳秒级）           | 较慢（毫秒级 HDD / 微秒级 SSD） |
      | 持久性 | *断电即失*（易失性）     | *断电也保存*（非易失性）       |
      | 作用  | CPU直接访问，运行程序、数据缓存 | 长期存储文件和系统数据           |
      | 成本  | 单位容量更贵            | 更便宜                   |
      | 容量  | 相对较小              | 大容量                   |
    ]
  - 你了解的文件是什么样的？
    - 通俗地说：文件 = 一段持久保存的数据 + 名字
    - 在操作系统视角，文件具有这些特性
      - 存储在磁盘等长期介质上
      - 有名字、有路径（用来访问）
      - 有长度、权限、时间戳等属性
      - 被视为一个字节流（对应用程序透明）
      - 是操作系统文件系统管理的对象
    - 常见文件类型
      #three-line-table[
        | 类别   | 示例             | 特点         |
        | ---- | -------------- | ---------- |
        | 普通文件 | .txt .jpg .exe | 数据或程序      |
        | 目录   | /home/xx       | 存储文件名和路径关系 |
        | 特殊文件 | /dev/sda       | 设备抽象       |
      ]
  - 持续保存数据如何组织？
    - 为了把数据稳妥地放在磁盘上、还找得到，操作系统做了组织规划：
      - 分配磁盘空间（文件存哪里）
      - 索引定位（如何快速找到）
      - 目录结构（文件怎么组织）
      - 访问权限（谁能操作）
      - 元数据管理（大小时间属性等）
      - 保证可靠性（断电崩溃不丢文件）
    - 典型数据组织方式
      #three-line-table[
        | 组织方式          | 思路        | 说明         |
        | ------------- | --------- | ---------- |
        | 线性连续存储        | 连续磁盘块     | 读写快但容易碎片化  |
        | 链式存储          | 每块指向下一块   | 查找可能慢      |
        | 索引存储（如 inode） | 独立索引指向数据块 | 现代文件系统主流方式 |
      ]
      实际文件系统常用 inode + 数据块，比如 EXT4、XFS、Unix FS
]

=== 文件

==== 文件的概念

*什么是文件系统？*
- 文件系统是存储设备上组织文件的*方法和数据结构*
  #figure(
    image("pic/2025-11-05-22-43-48.png", width: 80%),
    numbering: none,
  )
- 文件系统是操作系统中负责文件命名、存储和检索的*子系统*
  #figure(
    image("pic/2025-11-05-22-46-17.png", width: 80%),
    numbering: none,
  )

*什么是文件？*
- 文件是具有符号名，由字节序列构成的*数据项集合*
  - 文件是文件系统的基本*数据单位*
- *文件名*是文件的标识符号
- *文件头*：文件系统元数据中的文件信息
  - 文件属性：名称、类型、位置、创建时间、…
  - 文件存储位置和顺序
  #three-line-table[
    | 项           | 解释                         |
    | ----------- | -------------------------- |
    | 文件本质        | 字节序列（OS不关心内容格式）            |
    | 文件名         | 标识符（给人看的，不一定对应物理位置）        |
    | 文件头（inode等） | 文件元数据：记录大小、位置、权限等          |
    | 文件属性        | 名称、类型、长度、位置、创建/访问/修改时间、权限… |
  ]

*一切都是文件*
- UNIX类操作系统的设计哲学：*一切皆文件*
  - 普通文件，目录文件
  - 字符设备文件（如键盘，鼠标...）
  - 块设备文件（如硬盘，光驱...）
  - 网络文件（socket ...）等等
  #three-line-table[
    | 类型      | 示例                |
    | ------- | ----------------- |
    | 普通文件    | \*.txt, \*.c, \*.bin |
    | 目录文件    | `/home/user/`     |
    | 字符设备文件  | 键盘、鼠标 `/dev/tty`  |
    | 块设备文件   | 磁盘 `/dev/sda`     |
    | 网络文件    | socket            |
    | 管道、FIFO | 进程间通信             |
  ]
- 所有一切均抽象成文件，提供了*统一的接口*，方便应用程序调用
  - `read() / write() / open() / close()`

*文件视图*
- *用户的文件视图*
  - 持久存储的数据结构
  - 系统调用接口：*字节序列*的集合(UNIX)
- *操作系统的文件视图*
  - *数据块*的集合
  - 数据块是逻辑存储单元，而*扇区*是物理存储单元
*文件中数据的内部结构*
- 与应用相关
  - 无结构：文本文件
  - 简单结构：CSV、JSON等格式化文件
  - 复杂结构：Word文件、ELF可执行文件

==== 文件操作

*文件的基本操作*
- 进程*读文件*
  - 获取文件所在的数据块
  - 返回数据块内对应部分
- 进程*写文件*
  - 获取数据块
  - 修改数据块中对应部分
  - 写回数据块
  #figure(
    image("pic/2025-11-05-22-59-33.png", width: 80%),
    numbering: none,
  )
  - CPU 并不会直接对磁盘读写，磁盘→内存缓冲区→用户进程 是标准路径
  - 即使程序只写 1 byte，文件系统一般也要操作 4KB 的块；所以 `getc()/putc()` 虽看起来是字节操作，本质是块级操作 + 缓冲优化

*文件的基本操作单位*
- 文件系统中的基本操作单位是*数据块*
  - 例如，`getc()`和`putc()`即使每次只访问1字节的数据，也需要缓存目标数据4096字节
  #three-line-table[
    | 名称        | 含义         | 示例          |
    | --------- | ---------- | ----------- |
    | 扇区 Sector | 磁盘物理最小单位   | 512B or 4KB |
    | 块 Block   | 文件系统逻辑最小单位 | 通常 4KB      |
    | 字节 Byte   | 应用层最小单位    | 1B          |
  ]
  内核通过页面缓存 Page Cache来减少磁盘访问

*文件的访问模式*
- 顺序访问: 按字节依次读取
  - 把一维数据映射到文件中
- 随机访问: 从任意位置读写
  - 把一个复杂结构(矩阵)映射到文件中
- 索引访问: 依据数据特征索引
  - 数据库访问是一种基于索引的访问

*文件访问控制*
- 多用户操作系统中的*文件共享*是很必要的
- 访问控制
  - 用户对文件的访问权限
  - 读、写、执行、删除
- 文件访问控制列表(ACL-Access Control List)
  - `<文件实体, 权限>`更精细，现代系统如 NTFS 支持
- UNIX模式
  - `<用户|组|所有人, 读|写|可执行>`
  - 用户标识ID
  - 组标识ID

*多进程如何访问共享文件？*
- 文件是一类共享资源
  - 需要互斥访问
  - 采用类似的同步互斥技术
    - 读写锁
  #three-line-table[
    | 类型         | 解释          |
    | ---------- | ----------- |
    | 互斥锁        | 防止并发修改      |
    | 读写锁 RWLock | 多读单写        |
    | 文件锁 flock  | POSIX 文件锁接口 |
  ]

==== 文件描述符

*应用程序如何访问文件？*
- 应用访问文件数据前必须先“打开”文件，获得*文件描述符*
- 再进一步通过文件描述符（File Descriptor，fd）读写文件
  ```
  fd = open(name, flag);
  read(fd, …);
  close(fd);
  ```

*文件描述符* 当应用程序请求内核打开/新建一个文件时，内核返回一个文件描述符用于*对应这个打开/新建的文件*。
- 形式上，文件描述符是一个*非负整数*
- 实际上，文件描述符是一个*索引值*，指向内核为每一个进程所维护的该进程打开文件的记录表
  #figure(
    image("pic/2025-11-05-23-09-53.png", width: 80%),
    numbering: none,
  )

*打开文件表*
- 内核*跟踪*进程打开的所有文件
  - 操作系统为*每个进程*维护一个打开的文件描述符表
  - 一个*系统级*的打开文件表
  - *i-node*表指中向具体的文件内容
  #three-line-table[
    | 层级          | 内容             | 说明            |
    | ----------- | -------------- | ------------- |
    | *进程打开文件表* | 文件描述符 & 文件指针   | 每个进程自己维护，fd索引 |
    | *系统打开文件表* | 文件状态、访问模式、打开计数 | 所有进程共享        |
    | *inode 表* | 文件元数据与磁盘地址     | 指向真实文件数据块     |
  ]
- 内核在*打开文件表*中*维护打开文件状态和信息*
  - 文件指针
    - 最近一次读写位置
    - 每个进程分别维护自己的打开文件指针
  - 文件打开计数
    - 当前打开文件的次数
    - 最后一个进程关闭文件时，将其从打开文件表中移除
  - 文件的磁盘位置
    - 缓存数据访问信息
  - 访问权限
    - 每个进程的文件访问模式信息
  #three-line-table[
    | 信息            | 存储位置  | 作用             |
    | ------------- | ----- | -------------- |
    | 文件指针 (offset) | 进程级   | 记录读写位置         |
    | 访问模式 (R/W/X)  | 系统级   | 管权限            |
    | 打开计数          | 系统级   | 引用计数，最后一个关闭才释放 |
    | 缓存/磁盘位置       | inode | 文件数据在哪         |
  ]
*默认文件描述符*
- UNIX 系统启动时自动打开三个文件：
  #three-line-table[
    | fd | 名称     | 含义       |
    | -- | ------ | -------- |
    | 0  | stdin  | 标准输入（键盘） |
    | 1  | stdout | 标准输出（屏幕） |
    | 2  | stderr | 错误输出（屏幕） |
  ]

=== 文件系统和文件组织

==== 文件系统的功能

*文件系统类型*
- #three-line-table[
    | 类别         | 示例                                      | 特点               |
    | ---------- | --------------------------------------- | ---------------- |
    | 磁盘文件系统     | FAT32, NTFS, ext2/ext3/ext4, ISO9660    | 本地磁盘/光盘文件存储      |
    | 网络/分布式文件系统 | NFS, SMB, AFS, GFS, Ceph                | 多机器共享文件          |
    | 特殊文件系统     | procfs (`/proc`), sysfs (`/sys`), tmpfs | 不存真实文件，内核接口或内存文件 |
  ]
  - `procfs` 就像内核数据的“假文件书架”
  - `sysfs` 是系统设备和驱动的窗口
  - `tmpfs` 放在内存里，速度快
*虚拟文件系统 (VFS)*
- VFS 是一个抽象层，用来统一不同文件系统接口
- 它屏蔽底层差异，使 Linux 能同时访问 ext4、NFS、FAT、devfs 等
  #figure(
    image("pic/2025-11-05-23-17-53.png", width: 80%),
    numbering: none,
  )

*文件系统功能*
- 文件系统是操作系统中*管理持久性数据的子系统*，提供数据文件*命名、存储和检索*功能
  - 组织、检索、读写访问数据
  - 大多数计算机系统都有文件系统
- 分配文件磁盘空间
  - 管理文件块（位置和顺序）
  - 管理空闲空间(位置)
  - 分配算法 (策略)
- 管理文件集合
  - 组织：组织文件的控制结构和数据结构
  - 命名：给文件取名字
  - 定位：通过名字找到文件文件及其内容
- 数据可靠和安全
  - 安全：多层次保护数据安全
  - 可靠
    - 持久保存文件
    - 避免系统崩溃、数据丢失等

*文件系统组织结构*
- 分层/树状目录结构
  - 文件以目录的方式组织起来
  - *目录*是一类特殊的文件
  - 目录的内容是文件索引表`<文件名, 指向文件的指针>`
  ```
  /
  ├── bin
  ├── home
  │   └── user
  └── etc
      ├── config.cfg
      └── hosts
  ```

==== 目录

*目录操作*
- 应用程序通过系统调用对目录进行操作
  - 搜索文件
  - 创建文件
  - 删除文件
  - 列目录
  - 重命名文件
- 目录就是*文件名 → 文件位置（inode）*的映射表，本质上是个「索引簿」
  #three-line-table[
    | 操作   | 示例                   |
    | ---- | -------------------- |
    | 搜索文件 | `open("a.txt")` 会查目录 |
    | 创建文件 | `creat()`            |
    | 删除文件 | `unlink()`           |
    | 列目录  | `ls`                 |
    | 重命名  | `mv old new`         |
  ]
*目录实现方式*
- 文件名的*线性列表*，包涵了指向数据块的指针
  - 编程简单、执行耗时
- 哈希表 – 哈希数据结构的线性表
  - 减少目录搜索时间
  - 可能有冲突 - 两个文件名的哈希值相同
- ext2/3 传统用线性扫描，ext4 和 XFS 支持哈希索引提升性能
  ```
  目录文件内容（简化）
  [name1 → inode#12]
  [name2 → inode#8]
  [name3 → inode#109]
  ```

*路径解析（遍历目录）*
- 解析 `./fs/inode.rs`
  - 读取 `.` 当前目录
  - 找到 `fs` 项 → 得到 `fs` 的 inode
  - 读取 `fs` 目录内容
  - 找到 `inode.rs` → 得到目标文件 `inode`
  - 进入 `inode` → 获取数据
- 所以访问文件不是跳一次，是逐级查目录。
  - Linux 内核有目录项缓存（dentry cache）避免重复解析

*文件别名（多个名字指同一文件）*
- 多个文件名关联同一个文件
- 硬链接(hard link)
  - 多个文件项指向一个文件
- 软链接(soft link, symbolic link)
  - 新建文件，以存储文件名称的方式来指向其他文件
- inode：管理文件数据的结构
  #three-line-table[
    | 类型             | 指向          | 是否跨文件系统 | 链到目录 | 删除原文件后的结果   |
    | -------------- | ----------- | ------- | ---- | ----------- |
    | 硬链接 hard link  | 指向同一个 inode | ❌       | ❌    | 文件仍存在       |
    | 符号链接 soft link | 指向路径字符串     | ✅       | ✅    | 链断掉，变“悬空链接” |
  ]
  ```
  ln a.txt b.txt      # 硬链接
  ln -s a.txt link    # 软链接
  ```
  #figure(
    image("pic/2025-11-05-23-25-36.png", width: 80%),
    numbering: none,
  )
- 硬链接是对一个文件的引用，而软链接则是一个指向文件路径的指针
- *硬链接不能跨文件系统*，也不能链接到目录
  - 避免目录循环，所以不能链接到目录
- *软链接可以跨文件系统*，也可以链接到目录
- 如何避免目录中没有形成循环？
  - 只允许对文件的链接，不允许对子目录的链接
  - 增加链接时，用循环检测算法确定是否合理
  - 限制遍历文件目录的路径数量

*文件系统挂载*
- 文件系统需要先挂载才能被访问
  - 挂载(mount)是将一个文件系统连接到现有目录树的过程
  ```
  mount /dev/sdb1 /mnt/data
  ```

== 文件系统的设计与实现

#note(subname: [问题])[
  - 如何高效地管理和访问磁盘上存储的文件？
    - 文件系统要解决：
      #three-line-table[
        | 目标   | 说明              |
        | ---- | --------------- |
        | 定位文件 | 目录结构、inode、路径解析 |
        | 快速访问 | 数据结构、缓存、预读、写回   |
        | 节省空间 | 空闲空间管理、分配策略     |
        | 可靠性  | 崩溃恢复、写日志、元数据保护  |
        | 安全性  | 权限、ACL、隔离       |
        | 一致性  | 保证元数据和文件系统结构不乱  |
      ]
    - 实现方式包括：
      - 目录管理（哈希树、B+树、dentry cache）
      - 块管理（位图、链式、索引）
      - 磁盘数据布局（inode table、superblock）
      - 缓存机制（page cache、buffer cache）
      - 写策略（异步写、写回、日志 journaling）
      - VFS 抽象层
  - 内存管理方法可以借用来管理文件吗？
    - 能借，但不能直接照搬
      #three-line-table[
        | 内存概念          | 文件概念                     | 借鉴点           |
        | ------------- | ------------------------ | ------------- |
        | 页 Page        | 块 Block                  | 固定大小管理，提高定位效率 |
        | 页表 Page Table | inode 索引                 | 多级索引结构        |
        | TLB           | dentry cache/inode cache | 加缓存加速查找       |
        | 段 Segment     | 文件                       | 分模块组织、权限控制    |
      ]
]

=== 概述

*文件系统的分层结构*
#figure(
  image("pic/2025-11-05-23-33-20.png", width: 80%),
  numbering: none,
)
- VFS 是“翻译官”，上接统一接口，下接各种真实文件系统
*文件系统在计算机系统中的分层结构*
#figure(
  image("pic/2025-11-05-23-33-52.png", width: 70%),
  numbering: none,
)
*文件系统的用户视图与内核视图*
#figure(
  image("pic/2025-11-05-23-34-08.png", width: 80%),
  numbering: none,
)
#figure(
  image("pic/2025-11-05-23-34-34.png", width: 80%),
  numbering: none,
)
- inode 结构包含：
  - 文件元信息（权限、时间戳、大小）
  - 数据块指针（直接/间接）
- 数据真正放在数据块区

*虚拟文件系统* VFS, Virtual File System

- 一组所有文件系统都支持的数据结构和标准接口
- 磁盘的文件系统：直接把数据存储在磁盘中
  - 比如 Ext 2/3/4、XFS
- 内存的文件系统：内存辅助数据结构
  - 例如目录项
  #three-line-table[
    | 功能       | 解释                                |
    | -------- | --------------------------------- |
    | 统一接口     | 对用户永远是 open/read/write            |
    | 统一抽象     | inode、dentry、file 对象              |
    | 文件系统插件框架 | ext4, FAT, NFS 像插件一样挂进去           |
    | 高速缓存     | inode cache + dentry cache 提升查找速度 |
  ]
- 虚拟文件系统的功能
  - 目的：对所有不同文件系统的抽象
  - 功能
    - 提供相同的文件和文件系统*接口*
    - 管理所有文件和文件系统关联的*数据结构*
    - 高效*查询*例程：遍历文件系统
    - 与特定文件系统模块的交互

=== 文件系统的基本数据结构

*文件系统的存储视图*
- 文件卷控制块 (`superblock`)
- 文件控制块(`inode/vnode`)
- 目录项 (`dir_entry`)
- 数据块（`data block`）
  #figure(
    image("pic/2025-11-05-23-38-21.png", width: 80%),
    numbering: none,
  )

=== 文件缓存
=== 文件分配
=== 文件访问过程示例
